////////////////////////////////////////////////////////////////////////////////
// SoftKinetic DepthSense SDK
//
// COPYRIGHT AND CONFIDENTIALITY NOTICE - SOFTKINETIC CONFIDENTIAL
// INFORMATION
//
// All rights reserved to SOFTKINETIC SENSORS NV (a
// company incorporated and existing under the laws of Belgium, with
// its principal place of business at Boulevard de la Plainelaan 15,
// 1050 Brussels (Belgium), registered with the Crossroads bank for
// enterprises under company number 0811 341 454 - "Softkinetic
// Sensors").
//
// The source code of the SoftKinetic DepthSense Camera Drivers is
// proprietary and confidential information of Softkinetic Sensors NV.
//
// For any question about terms and conditions, please contact:
// info@softkinetic.com Copyright (c) 2002-2014 Softkinetic Sensors NV
////////////////////////////////////////////////////////////////////////////////

// automatically generated by dsic, do not edit
#ifndef _DEPTHSENSE_PUBLIC_HXX
#define _DEPTHSENSE_PUBLIC_HXX
/// The DepthSense Software Development Kit
namespace DepthSense
{
    class Interface;
    class AudioNode;
    class ColorNode;
    class DepthNode;
    class UnsupportedNode;
    class Context;
    class Device;
    class Node;
};
#include <vector>
#include <string>
#include <functional>
#include <DepthSenseAPI.h>
#include <Pointer.hxx>
#include <String.hxx>
#include <Vector.hxx>
#include <Type.hxx>
#include <Event.hxx>
namespace DSI
{
    class Client;
    class Marshalling;
    class CMarshalling;
}
namespace DepthSense
{
    namespace Utils
    {
        class BinaryReader;
    }
}
namespace DepthSense
{
    /// The image resolution
    ///   
    /// A type enumerating the various frame formats supported by
    /// DepthSense SDK.
    enum FrameFormat
    {
        FRAME_FORMAT_UNKNOWN = 0,/*!< unknown */
        FRAME_FORMAT_QQVGA = 1,/*!< QQVGA (160x120) */
        FRAME_FORMAT_QCIF = 2,/*!< QCIF (176x144) */
        FRAME_FORMAT_HQVGA = 3,/*!< HQVGA (240x160) */
        FRAME_FORMAT_QVGA = 4,/*!< QVGA (320x240) */
        FRAME_FORMAT_CIF = 5,/*!< CIF (352x288) */
        FRAME_FORMAT_HVGA = 6,/*!< HVGA (480x320) */
        FRAME_FORMAT_VGA = 7,/*!< VGA (640x480) */
        FRAME_FORMAT_WXGA_H = 8,/*!< WXGA_H (1280x720) */
        FRAME_FORMAT_DS311 = 9,/*!< DS311 (320x120) */
        FRAME_FORMAT_XGA = 10,/*!< XGA (1024x768) */
        FRAME_FORMAT_SVGA = 11,/*!< SVGA (800x600) */
        FRAME_FORMAT_OVVGA = 12,/*!< OVVGA (636x480) */
        FRAME_FORMAT_WHVGA = 13,/*!< WHVGA (640x240) */
        FRAME_FORMAT_NHD = 14,/*!< nHD (640x360) */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String FrameFormat_toString_p (FrameFormat value);
    #endif
    /// Converts a DepthSense::FrameFormat value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::FrameFormat, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string FrameFormat_toString (FrameFormat value)
    {
        return FrameFormat_toString_p(value).unmarshal();
    }
    /// The image compression type
    ///
    /// A type enumerating the various compression types supported by
    /// DepthSense SDK.
    enum CompressionType
    {
        COMPRESSION_TYPE_YUY2 = 0,/*!< Y'UV422 */
        COMPRESSION_TYPE_MJPEG = 1,/*!< MJPEG */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CompressionType_toString_p (CompressionType value);
    #endif
    /// Converts a DepthSense::CompressionType value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CompressionType, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CompressionType_toString (CompressionType value)
    {
        return CompressionType_toString_p(value).unmarshal();
    }
    /// The auto exposure mode
    ///
    /// The supported auto exposure modes.
    enum ExposureAuto
    {
        EXPOSURE_AUTO_MANUAL = 0,/*!< manual */
        EXPOSURE_AUTO_APERTURE_PRIORITY = 1,/*!< aperture priority */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String ExposureAuto_toString_p (ExposureAuto value);
    #endif
    /// Converts a DepthSense::ExposureAuto value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::ExposureAuto, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string ExposureAuto_toString (ExposureAuto value)
    {
        return ExposureAuto_toString_p(value).unmarshal();
    }
    /// The power line frequency
    ///
    /// The supported power line frequencies.
    enum PowerLineFrequency
    {
        POWER_LINE_FREQUENCY_DISABLED = 0,/*!< disabled */
        POWER_LINE_FREQUENCY_50HZ = 1,/*!< 50 Hz */
        POWER_LINE_FREQUENCY_60HZ = 2,/*!< 60 Hz */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String PowerLineFrequency_toString_p (PowerLineFrequency value);
    #endif
    /// Converts a DepthSense::PowerLineFrequency value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::PowerLineFrequency, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string PowerLineFrequency_toString (PowerLineFrequency value)
    {
        return PowerLineFrequency_toString_p(value).unmarshal();
    }
    /// The camera plane to project on
    ///
    /// The camera plane to project the 3D points on.
    enum CameraPlane
    {
        CAMERA_PLANE_COLOR = 0,/*!< the color plane */
        CAMERA_PLANE_DEPTH = 1,/*!< the depth plane */
    };
    #ifndef DEPTHSENSE_DOC
    DEPTHSENSE_API DSI::String CameraPlane_toString_p (CameraPlane value);
    #endif
    /// Converts a DepthSense::CameraPlane value to a string
    ///
    /// Converts the provided enumeration value to a string.
    ///
    /// \param value the enumeration value to convert
    ///
    /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::CameraPlane, its numeric representation
    ///
    /// \exception std::bad_alloc not enough memory to perform the requested operation
    static inline std::string CameraPlane_toString (CameraPlane value)
    {
        return CameraPlane_toString_p(value).unmarshal();
    }
};
namespace DepthSense
{
    /// \struct Vertex DepthSense.hxx
    /// A point in space as defined by its integer coordinates
    ///   
    /// The Vertex struct holds the position of a point in space as
    /// defined by its 3D integer coordinates.
    struct DEPTHSENSE_API Vertex
    {
        Vertex ();
        /// Constructs a Vertex instance
        ///
        /// Constructs a Vertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Vertex::x field
        /// \param y the value of the Vertex::y field
        /// \param z the value of the Vertex::z field
        Vertex (int16_t x, int16_t y, int16_t z);
        /// the x value
        int16_t x;
        /// the y value
        int16_t y;
        /// the z value
        int16_t z;
        /// Compares two Vertex instances for equality
        ///
        /// Checks whether the current Vertex instance is equal to the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Vertex& other) const;
        /// Compares two Vertex instances for inequality
        ///
        /// Checks whether the current Vertex instance is different from the Vertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Vertex& other) const;
    };
    /// \struct FPVertex DepthSense.hxx
    /// A point in space as defined by its floating point coordinates
    ///   
    /// The FPVertex struct holds the position of a point in space as
    /// defined by its 3D floating point coordinates.
    struct DEPTHSENSE_API FPVertex
    {
        FPVertex ();
        /// Constructs a FPVertex instance
        ///
        /// Constructs a FPVertex instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the FPVertex::x field
        /// \param y the value of the FPVertex::y field
        /// \param z the value of the FPVertex::z field
        FPVertex (float x, float y, float z);
        /// the x value
        float x;
        /// the y value
        float y;
        /// the z value
        float z;
        /// Compares two FPVertex instances for equality
        ///
        /// Checks whether the current FPVertex instance is equal to the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPVertex& other) const;
        /// Compares two FPVertex instances for inequality
        ///
        /// Checks whether the current FPVertex instance is different from the FPVertex instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPVertex& other) const;
    };
    /// \struct UV DepthSense.hxx
    /// UV coordinates
    ///   
    /// The UV struct holds the UV coordinates of a point of a UV map.
    struct DEPTHSENSE_API UV
    {
        UV ();
        /// Constructs a UV instance
        ///
        /// Constructs a UV instance, initializing the instance fields with the provided values.
        ///
        /// \param u the value of the UV::u field
        /// \param v the value of the UV::v field
        UV (float u, float v);
        /// the u value
        float u;
        /// the v value
        float v;
        /// Compares two UV instances for equality
        ///
        /// Checks whether the current UV instance is equal to the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const UV& other) const;
        /// Compares two UV instances for inequality
        ///
        /// Checks whether the current UV instance is different from the UV instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const UV& other) const;
    };
    /// \struct IntrinsicParameters DepthSense.hxx
    /// The intrinsic parameters of the camera system
    ///   
    /// The IntrinsicParameters struct holds the intrinsic parameters
    /// of the camera system.
    struct DEPTHSENSE_API IntrinsicParameters
    {
        IntrinsicParameters ();
        /// Constructs a IntrinsicParameters instance
        ///
        /// Constructs a IntrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param width the value of the IntrinsicParameters::width field
        /// \param height the value of the IntrinsicParameters::height field
        /// \param fx the value of the IntrinsicParameters::fx field
        /// \param fy the value of the IntrinsicParameters::fy field
        /// \param cx the value of the IntrinsicParameters::cx field
        /// \param cy the value of the IntrinsicParameters::cy field
        /// \param k1 the value of the IntrinsicParameters::k1 field
        /// \param k2 the value of the IntrinsicParameters::k2 field
        /// \param k3 the value of the IntrinsicParameters::k3 field
        /// \param p1 the value of the IntrinsicParameters::p1 field
        /// \param p2 the value of the IntrinsicParameters::p2 field
        IntrinsicParameters (int32_t width, int32_t height, float fx, float fy, float cx, float cy, float k1, float k2, float k3, float p1, float p2);
        /// the width of the map when the frame was captured
        int32_t width;
        /// the height of the map when the frame was captured
        int32_t height;
        /// the focal length along the x axis, expressed in pixel units
        float fx;
        /// the focal length along the y axis, expressed in pixel units
        float fy;
        /// the central point along the x axis, expressed in pixel units
        float cx;
        /// the central point along the y axis, expressed in pixel units
        float cy;
        /// the first radial distortion coefficient
        float k1;
        /// the second radial distortion coefficient
        float k2;
        /// the third radial distortion coefficient
        float k3;
        /// the first tangential distortion coefficient
        float p1;
        /// the second tangential distortion coefficient
        float p2;
        /// Compares two IntrinsicParameters instances for equality
        ///
        /// Checks whether the current IntrinsicParameters instance is equal to the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const IntrinsicParameters& other) const;
        /// Compares two IntrinsicParameters instances for inequality
        ///
        /// Checks whether the current IntrinsicParameters instance is different from the IntrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const IntrinsicParameters& other) const;
    };
    /// \struct ExtrinsicParameters DepthSense.hxx
    /// The extrinsic parameters of the camera system
    ///   
    /// The ExtrinsicsParameters struct holds the extrinsic parameters
    /// of the camera system. Elements are given row by row.
    struct DEPTHSENSE_API ExtrinsicParameters
    {
        ExtrinsicParameters ();
        /// Constructs a ExtrinsicParameters instance
        ///
        /// Constructs a ExtrinsicParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param r11 the value of the ExtrinsicParameters::r11 field
        /// \param r12 the value of the ExtrinsicParameters::r12 field
        /// \param r13 the value of the ExtrinsicParameters::r13 field
        /// \param r21 the value of the ExtrinsicParameters::r21 field
        /// \param r22 the value of the ExtrinsicParameters::r22 field
        /// \param r23 the value of the ExtrinsicParameters::r23 field
        /// \param r31 the value of the ExtrinsicParameters::r31 field
        /// \param r32 the value of the ExtrinsicParameters::r32 field
        /// \param r33 the value of the ExtrinsicParameters::r33 field
        /// \param t1 the value of the ExtrinsicParameters::t1 field
        /// \param t2 the value of the ExtrinsicParameters::t2 field
        /// \param t3 the value of the ExtrinsicParameters::t3 field
        ExtrinsicParameters (float r11, float r12, float r13, float r21, float r22, float r23, float r31, float r32, float r33, float t1, float t2, float t3);
        /// the r11 parameter
        float r11;
        /// the r12 parameter
        float r12;
        /// the r13 parameter
        float r13;
        /// the r21 parameter
        float r21;
        /// the r22 parameter
        float r22;
        /// the r32 parameter
        float r23;
        /// the r31 parameter
        float r31;
        /// the r32 parameter
        float r32;
        /// the r33 parameter
        float r33;
        /// the t1 parameter
        float t1;
        /// the t2 parameter
        float t2;
        /// the t3 parameter
        float t3;
        /// Compares two ExtrinsicParameters instances for equality
        ///
        /// Checks whether the current ExtrinsicParameters instance is equal to the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const ExtrinsicParameters& other) const;
        /// Compares two ExtrinsicParameters instances for inequality
        ///
        /// Checks whether the current ExtrinsicParameters instance is different from the ExtrinsicParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const ExtrinsicParameters& other) const;
    };
    /// \struct StereoCameraParameters DepthSense.hxx
    /// The intrinsic and extrinsic parameters of the camera system
    ///   
    /// The StereoCameraParameters holds the intrinsic and extrinsic
    /// parameters of the camera system.
    struct DEPTHSENSE_API StereoCameraParameters
    {
        StereoCameraParameters ();
        /// Constructs a StereoCameraParameters instance
        ///
        /// Constructs a StereoCameraParameters instance, initializing the instance fields with the provided values.
        ///
        /// \param depthIntrinsics the value of the StereoCameraParameters::depthIntrinsics field
        /// \param colorIntrinsics the value of the StereoCameraParameters::colorIntrinsics field
        /// \param extrinsics the value of the StereoCameraParameters::extrinsics field
        StereoCameraParameters (DepthSense::IntrinsicParameters depthIntrinsics, DepthSense::IntrinsicParameters colorIntrinsics, DepthSense::ExtrinsicParameters extrinsics);
        /// The intrinsic parameters of the depth camera
        DepthSense::IntrinsicParameters depthIntrinsics;
        /// The intrinsic parameters of the color camera
        DepthSense::IntrinsicParameters colorIntrinsics;
        /// The extrinsic parameters of the system
        DepthSense::ExtrinsicParameters extrinsics;
        /// Compares two StereoCameraParameters instances for equality
        ///
        /// Checks whether the current StereoCameraParameters instance is equal to the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const StereoCameraParameters& other) const;
        /// Compares two StereoCameraParameters instances for inequality
        ///
        /// Checks whether the current StereoCameraParameters instance is different from the StereoCameraParameters instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const StereoCameraParameters& other) const;
    };
    /// \struct Point2D DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates
    ///
    /// The Point2D struct holds the position of a point in the
    /// cartesian space as defined by its floating point pixel
    /// coordinates. The origin of the coordinate system is the
    /// topleft corner of the image.
    struct DEPTHSENSE_API Point2D
    {
        Point2D ();
        /// Constructs a Point2D instance
        ///
        /// Constructs a Point2D instance, initializing the instance fields with the provided values.
        ///
        /// \param x the value of the Point2D::x field
        /// \param y the value of the Point2D::y field
        Point2D (float x, float y);
        /// the x coordinate
        float x;
        /// the y coordinate
        float y;
        /// Compares two Point2D instances for equality
        ///
        /// Checks whether the current Point2D instance is equal to the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Point2D& other) const;
        /// Compares two Point2D instances for inequality
        ///
        /// Checks whether the current Point2D instance is different from the Point2D instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Point2D& other) const;
    };
    /// \struct Extended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its integral cartesian depth
    ///
    /// The Extended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its integral cartesian depth.
    struct DEPTHSENSE_API Extended2DPoint
    {
        Extended2DPoint ();
        /// Constructs a Extended2DPoint instance
        ///
        /// Constructs a Extended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the Extended2DPoint::point field
        /// \param depth the value of the Extended2DPoint::depth field
        Extended2DPoint (DepthSense::Point2D point, int16_t depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location, expressed in millimeters
        int16_t depth;
        /// Compares two Extended2DPoint instances for equality
        ///
        /// Checks whether the current Extended2DPoint instance is equal to the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Extended2DPoint& other) const;
        /// Compares two Extended2DPoint instances for inequality
        ///
        /// Checks whether the current Extended2DPoint instance is different from the Extended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Extended2DPoint& other) const;
    };
    /// \struct FPExtended2DPoint DepthSense.hxx
    /// A point in the cartesian space as defined by its floating
    /// point pixel coordinates, and its floating point cartesian
    /// depth
    ///
    /// The FPExtended2DPoint struct holds the position of a point in
    /// the cartesian space as defined by its floating point pixel
    /// coordinates, and its floating point cartesian depth.
    struct DEPTHSENSE_API FPExtended2DPoint
    {
        FPExtended2DPoint ();
        /// Constructs a FPExtended2DPoint instance
        ///
        /// Constructs a FPExtended2DPoint instance, initializing the instance fields with the provided values.
        ///
        /// \param point the value of the FPExtended2DPoint::point field
        /// \param depth the value of the FPExtended2DPoint::depth field
        FPExtended2DPoint (DepthSense::Point2D point, float depth);
        /// the coordinates of the 2D point
        DepthSense::Point2D point;
        /// the depth at this location.
        float depth;
        /// Compares two FPExtended2DPoint instances for equality
        ///
        /// Checks whether the current FPExtended2DPoint instance is equal to the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const FPExtended2DPoint& other) const;
        /// Compares two FPExtended2DPoint instances for inequality
        ///
        /// Checks whether the current FPExtended2DPoint instance is different from the FPExtended2DPoint instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const FPExtended2DPoint& other) const;
    };
    /// \struct Version DepthSense.hxx
    /// DepthSense version information
    ///
    /// The Version struct contains version information for the DepthSenseSDK software.
    struct DEPTHSENSE_API Version
    {
        Version ();
        /// Constructs a Version instance
        ///
        /// Constructs a Version instance, initializing the instance fields with the provided values.
        ///
        /// \param major the value of the Version::major field
        /// \param minor the value of the Version::minor field
        /// \param patch the value of the Version::patch field
        /// \param build the value of the Version::build field
        Version (int32_t major, int32_t minor, int32_t patch, int32_t build);
        /// the major version number
        int32_t major;
        /// the minor version number
        int32_t minor;
        /// the patch level
        int32_t patch;
        /// the package build number
        int32_t build;
        /// Compares two Version instances for equality
        ///
        /// Checks whether the current Version instance is equal to the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is equal to instance \p other
        bool operator== (const Version& other) const;
        /// Compares two Version instances for inequality
        ///
        /// Checks whether the current Version instance is different from the Version instance \p other.
        ///
        /// \param other the instance to compare the current instance with
        /// \return whether the current instance is different from instance \p other
        bool operator!= (const Version& other) const;
    };
};
namespace DepthSense
{
    /// \class Exception DepthSense.hxx
    /// The base exception class
    ///   
    /// The Exception class is the common base class for all
    /// DepthSense exception types. It is never thrown directly, one
    /// of its subclasses is.
    ///
    /// DepthSense exceptions feature automatic memory management,
    /// implemented with reference counted smart pointer mechanisms.
    ///
    /// The Exception class derives from \c std::exception.
    class DEPTHSENSE_API Exception : public std::exception
    {
        #ifndef DEPTHSENSE_DOC
        protected:
        void* _data;
        #endif
        public:
        #ifndef DEPTHSENSE_DOC
        Exception (const Exception& other);
        Exception& operator= (const Exception& other);
        virtual ~Exception () throw ();
        virtual const char* what () const throw ();
        #endif
        protected:
        Exception ();
        Exception (void* data);
        private:
        Exception (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setMessage (std::string value);
        #endif
        public:
        /// Returns the error message
        ///   
        /// Returns the error message contained in the current
        /// exception object.
        ///
        /// \return the error message
        std::string getMessage () const;
        private:
        friend class PException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ArgumentException DepthSense.hxx
    /// The type of the exception thrown when an argument is unset or invalid
    ///   
    /// ArgumentException is thrown when a method argument or property
    /// value is unset when it should be set or is outside of the
    /// range of allowed values.
    class DEPTHSENSE_API ArgumentException : public DepthSense::Exception
    {
        protected:
        ArgumentException ();
        ArgumentException (void* data);
        private:
        ArgumentException (DepthSense::Utils::BinaryReader& reader);
        #ifndef DEPTHSENSE_DOC
        protected:
        void setParameterName (std::string value);
        #endif
        public:
        /// Returns the name of the corresponding parameter
        ///   
        /// Returns the name of the method parameter whose argument is
        /// invalid. For a property value, this name is always \c
        /// value.
        ///
        /// \return the parameter name
        std::string getParameterName () const;
        private:
        friend class PArgumentException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TransportException DepthSense.hxx
    /// The type of the exception thrown when a network or protocol
    /// error has occurred
    ///
    /// TransportException is thrown when a network I/O operation has
    /// failed, or when an invalid protocol packet has been received.
    class DEPTHSENSE_API TransportException : public DepthSense::Exception
    {
        protected:
        TransportException ();
        TransportException (void* data);
        private:
        TransportException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTransportException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InitializationException DepthSense.hxx
    /// The type of the exception thrown when an initialization error
    /// has occurred
    ///
    /// InitializationException is thrown when a component has failed
    /// to initialize properly.
    class DEPTHSENSE_API InitializationException : public DepthSense::Exception
    {
        protected:
        InitializationException ();
        InitializationException (void* data);
        private:
        InitializationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInitializationException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class TimeoutException DepthSense.hxx
    /// The type of the exception thrown when a timeout condition occurs
    ///
    /// TimeoutException is thrown when the user-provided timeout of a
    /// method accepting a timeout parameter expires.
    class DEPTHSENSE_API TimeoutException : public DepthSense::Exception
    {
        protected:
        TimeoutException ();
        TimeoutException (void* data);
        private:
        TimeoutException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PTimeoutException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class ConfigurationException DepthSense.hxx
    /// The type of the exception thrown when a valid configuration
    /// failed to apply
    ///   
    /// ConfigurationException is thrown when a valid configuration
    /// could not be applied because of a device or software error.
    ///
    /// Contrast with ArgumentException, which is thrown by
    /// AudioNode::setConfiguration(), ColorNode::setConfiguration()
    /// and DepthNode::setConfiguration() when the user-provided
    /// configuration is invalid.
    class DEPTHSENSE_API ConfigurationException : public DepthSense::Exception
    {
        protected:
        ConfigurationException ();
        ConfigurationException (void* data);
        private:
        ConfigurationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PConfigurationException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class StreamingException DepthSense.hxx
    /// The type of the exception thrown when a streaming error has
    /// occurred
    ///
    /// StreamingException is thrown when a device or software error
    /// prevents streaming from starting or from resuming after a
    /// configuration change.
    class DEPTHSENSE_API StreamingException : public DepthSense::Exception
    {
        protected:
        StreamingException ();
        StreamingException (void* data);
        private:
        StreamingException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PStreamingException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class UnauthorizedAccessException DepthSense.hxx
    /// The type of the exception thrown when access to a privileged
    /// operation is denied
    ///    
    /// UnauthorizedAccessException is thrown when a privileged method
    /// is called or when a privileged property is set.
    ///
    /// A privileged method or property is one which requires
    /// exclusive control of a device or node. Such exclusive control
    /// can be obtained with a call to Context::requestControl().
    class DEPTHSENSE_API UnauthorizedAccessException : public DepthSense::Exception
    {
        protected:
        UnauthorizedAccessException ();
        UnauthorizedAccessException (void* data);
        private:
        UnauthorizedAccessException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PUnauthorizedAccessException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class InvalidOperationException DepthSense.hxx
    /// The type of the exception thrown when the current state of an
    /// object does not support the requested operation
    ///   
    /// InvalidOperationException is thrown when an operation is not valid
    /// because of the current state of an object.
    ///
    /// Contrast with NotSupportedException, which is thrown when an
    /// operation is not implemented, regardless of any program or
    /// library state.
    class DEPTHSENSE_API InvalidOperationException : public DepthSense::Exception
    {
        protected:
        InvalidOperationException ();
        InvalidOperationException (void* data);
        private:
        InvalidOperationException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PInvalidOperationException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class NotSupportedException DepthSense.hxx
    /// The type of the exception thrown when a unsupported operation
    /// is requested
    ///
    /// NotSupportedException is thrown when an unimplemented method
    /// or property is used.
    class DEPTHSENSE_API NotSupportedException : public DepthSense::Exception
    {
        protected:
        NotSupportedException ();
        NotSupportedException (void* data);
        private:
        NotSupportedException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PNotSupportedException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
    /// \class IOException DepthSense.hxx
    /// The type of the exception throw when a device or file I/O
    /// operation has failed
    ///   
    /// IOException is thrown when an operation on a device or a file
    /// has failed because of an I/O error.
    class DEPTHSENSE_API IOException : public DepthSense::Exception
    {
        protected:
        IOException ();
        IOException (void* data);
        private:
        IOException (DepthSense::Utils::BinaryReader& reader);
        private:
        friend class PIOException;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
    };
};
namespace DepthSense
{
    /// \class Interface DepthSense.hxx
    /// The base interface class
    ///
    /// The Interface class is the common base class for all
    /// DepthSense interfaces. It provides facilities for
    /// introspecting the runtime type of an object and for setting or
    /// unsetting the current instance.
    ///
    /// The Interface class and its subclasses feature automatic
    /// memory management, implemented with reference counted smart
    /// pointer mechanisms.
    class Interface
    {
        private:
        void* _instance;
        DEPTHSENSE_API Interface (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const Interface& other);
        DEPTHSENSE_API Interface& operator= (const Interface& other);
        #endif
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        DEPTHSENSE_API ~Interface ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Interface (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::UnsupportedNode& iface);
        DEPTHSENSE_API Interface (const DepthSense::Context& iface);
        DEPTHSENSE_API Interface (const DepthSense::Device& iface);
        DEPTHSENSE_API Interface (const DepthSense::Node& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Interface& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Interface& other) const;
        #endif
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        /// Returns the DepthSense::Interface type object
        ///
        /// Returns the DepthSense::Interface type object
        ///
        /// \return the DepthSense::Interface type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct PropertyChangedData DepthSense.hxx
        /// Holds the DepthSense::Interface::PropertyChangedEvent arguments
        ///
        /// The PropertyChangedData struct holds the DepthSense::Interface::PropertyChangedEvent parameters and is passed to callbacks connected to that event.
        struct PropertyChangedData
        {
            /// the property whose value has changed
            DepthSense::PropertyBase property;
        };
        /// \class PropertyChangedEvent DepthSense.hxx
        /// Event raised when a property has changed
        ///
        /// The \c propertyChanged event is raised when the value of a
        /// property has changed.
        ///
        /// \param property the property whose value has changed
        class PropertyChangedEvent : public DepthSense::Event<DepthSense::Interface, PropertyChangedData>
        {
            private:
            PropertyChangedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Interface, PropertyChangedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(func)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Interface, PropertyChangedData, void (*) (DepthSense::Interface obj, DepthSense::PropertyBase property, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    _func(obj, data.property, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Interface obj, PropertyChangedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Interface, PropertyChangedData, ObjectType, void (ObjectType::*) (DepthSense::Interface obj, DepthSense::PropertyBase property)>::_method))(obj, data.property);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Interface, PropertyChangedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Interface, PropertyChangedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Interface obj, DepthSense::PropertyBase property, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::Interface::PropertyChangedData data))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Interface, PropertyChangedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p property</td><td>the property whose value has changed</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Interface obj, DepthSense::PropertyBase property))
            {
                DepthSense::Event<DepthSense::Interface, PropertyChangedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
    };
    /// \class Node DepthSense.hxx
    /// Represents a stream data source
    ///   
    /// The Node class represents a stream data source belonging to a given
    /// device. A device may contain several nodes (depth and color sensors,
    /// and a microphone array).
    class Node
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Node (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        public:
        DEPTHSENSE_API Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Node (const Node& other);
        DEPTHSENSE_API Node& operator= (const Node& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Node ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Node (const DepthSense::Interface& iface);
        DEPTHSENSE_API Node (const DepthSense::AudioNode& iface);
        DEPTHSENSE_API Node (const DepthSense::ColorNode& iface);
        DEPTHSENSE_API Node (const DepthSense::DepthNode& iface);
        DEPTHSENSE_API Node (const DepthSense::UnsupportedNode& iface);
        template <class T>
        bool is () const;
        template <class T>
        T as () const;
        DEPTHSENSE_API bool operator== (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Node& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Node& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Node type object
        ///
        /// Returns the DepthSense::Node type object
        ///
        /// \return the DepthSense::Node type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class AudioNode DepthSense.hxx
    /// Represents an audio stream data source
    ///   
    /// The AudioNode class allows to capture audio data with the microphone
    /// array of a given camera device.
    class AudioNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API AudioNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API AudioNode (const AudioNode& other);
        DEPTHSENSE_API AudioNode& operator= (const AudioNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~AudioNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit AudioNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::AudioNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::AudioNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::AudioNode type object
        ///
        /// Returns the DepthSense::AudioNode type object
        ///
        /// \return the DepthSense::AudioNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of an audio node
        ///   
        /// The Configuration struct holds the configuration of an audio node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param channels the value of the Configuration::channels field
            /// \param bitsPerSample the value of the Configuration::bitsPerSample field
            /// \param sampleRate the value of the Configuration::sampleRate field
            Configuration (int32_t channels, int32_t bitsPerSample, int32_t sampleRate);
            /// the number of audio channels
            int32_t channels;
            /// the number of bits per sample
            int32_t bitsPerSample;
            /// the sample rate in Hz
            int32_t sampleRate;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// The node configuration
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::AudioNode::Configuration configuration;
        #endif
        /// Gets the value of the AudioNode::configuration property
        ///
        /// Gets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::Configuration getConfiguration ();
        /// Sets the value of the AudioNode::configuration property
        ///
        /// Sets the value of the AudioNode::configuration property.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::AudioNode::Configuration value);
        /// Checks whether property AudioNode::configuration is read-only
        ///
        /// Checks whether property AudioNode::configuration is read-only.
        ///
        /// The AudioNode::configuration property specifies the
        /// configuration of the audio node.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The AudioNode::configurations property specifies the list of
        /// supported node configurations.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::AudioNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::AudioNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the AudioNode::configurations property
        ///
        /// Gets the value of the AudioNode::configurations property.
        ///
        ///
        /// \return the value of the AudioNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::AudioNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::AudioNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The recording level
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property float inputMixerLevel;
        #endif
        /// Gets the value of the AudioNode::inputMixerLevel property
        ///
        /// Gets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::inputMixerLevel property
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getInputMixerLevel ();
        /// Sets the value of the AudioNode::inputMixerLevel property
        ///
        /// Sets the value of the AudioNode::inputMixerLevel property.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getInputMixerLevel(), inputMixerLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setInputMixerLevel (float value);
        /// Checks whether property AudioNode::inputMixerLevel is read-only
        ///
        /// Checks whether property AudioNode::inputMixerLevel is read-only.
        ///
        /// The AudioNode::inputMixerLevel property accepts a value
        /// ranging from 0.0 to 1.0.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::inputMixerLevel is read-only
        ///
        /// \sa setInputMixerLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool inputMixerLevelIsReadOnly ();
        /// Whether to mute the recording
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool mute;
        #endif
        /// Gets the value of the AudioNode::mute property
        ///
        /// Gets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the AudioNode::mute property
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getMute ();
        /// Sets the value of the AudioNode::mute property
        ///
        /// Sets the value of the AudioNode::mute property.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getMute(), muteIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setMute (bool value);
        /// Checks whether property AudioNode::mute is read-only
        ///
        /// Checks whether property AudioNode::mute is read-only.
        ///
        /// The AudioNode::mute property specifies whether to mute the
        /// recording.
        ///
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property AudioNode::mute is read-only
        ///
        /// \sa setMute()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool muteIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::AudioNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::AudioNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the audio data
            ::DepthSense::Pointer< uint8_t > audioData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::AudioNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in s
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in s
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when an audio sample is captured
        ///
        /// The \c newSampleReceived event is raised when an audio sample
        /// is captured.
        ///
        /// \param audioData the audio data
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in s
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in s
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::AudioNode, NewSampleReceivedData, void (*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::AudioNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::AudioNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.audioData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::AudioNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, DepthSense::AudioNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::AudioNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p audioData</td><td>the audio data</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::AudioNode obj, ::DepthSense::Pointer< uint8_t > audioData, DepthSense::AudioNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::AudioNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::AudioNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class ColorNode DepthSense.hxx
    /// Represents a color stream data source
    ///
    /// The ColorNode class allows to capture pixel data with the RGB sensor
    /// of a given camera device.
    class ColorNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API ColorNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API ColorNode (const ColorNode& other);
        DEPTHSENSE_API ColorNode& operator= (const ColorNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~ColorNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit ColorNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::ColorNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::ColorNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::ColorNode type object
        ///
        /// Returns the DepthSense::ColorNode type object
        ///
        /// \return the DepthSense::ColorNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a color node
        ///   
        /// The Configuration struct holds the configuration of a color node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param powerLineFrequency the value of the Configuration::powerLineFrequency field
            /// \param compression the value of the Configuration::compression field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::PowerLineFrequency powerLineFrequency, DepthSense::CompressionType compression);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the power line frequency in Hz
            DepthSense::PowerLineFrequency powerLineFrequency;
            /// the compression type
            DepthSense::CompressionType compression;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// Whether to enable the color map
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableColorMap;
        #endif
        /// Gets the value of the ColorNode::enableColorMap property
        ///
        /// Gets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableColorMap property
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableColorMap ();
        /// Sets the value of the ColorNode::enableColorMap property
        ///
        /// Sets the value of the ColorNode::enableColorMap property.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableColorMap(), enableColorMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableColorMap (bool value);
        /// Checks whether property ColorNode::enableColorMap is read-only
        ///
        /// Checks whether property ColorNode::enableColorMap is read-only.
        ///
        /// The ColorNode::enableColorMap property specifies whether
        /// to capture the color stream and make it available through
        /// the \c colorMap argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableColorMap is read-only
        ///
        /// \sa setEnableColorMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableColorMapIsReadOnly ();
        /// Whether to enable the compressed data
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property bool enableCompressedData;
        #endif
        /// Gets the value of the ColorNode::enableCompressedData property
        ///
        /// Gets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return the value of the ColorNode::enableCompressedData property
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableCompressedData ();
        /// Sets the value of the ColorNode::enableCompressedData property
        ///
        /// Sets the value of the ColorNode::enableCompressedData property.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableCompressedData(), enableCompressedDataIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableCompressedData (bool value);
        /// Checks whether property ColorNode::enableCompressedData is read-only
        ///
        /// Checks whether property ColorNode::enableCompressedData is read-only.
        ///
        /// The ColorNode::enableCompressedData property specifies
        /// whether to capture the compressed data and make it
        /// available through the \c compressedData argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        ///
        /// \return whether property ColorNode::enableCompressedData is read-only
        ///
        /// \sa setEnableCompressedData()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableCompressedDataIsReadOnly ();
        /// The node configuration
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ColorNode::Configuration configuration;
        #endif
        /// Gets the value of the ColorNode::configuration property
        ///
        /// Gets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return the value of the ColorNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::Configuration getConfiguration ();
        /// Sets the value of the ColorNode::configuration property
        ///
        /// Sets the value of the ColorNode::configuration property.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the node no longer exists
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::ColorNode::Configuration value);
        /// Checks whether property ColorNode::configuration is read-only
        ///
        /// Checks whether property ColorNode::configuration is read-only.
        ///
        /// The ColorNode::configuration property specifies the
        /// configuration of the color node.
        ///
        ///
        /// \return whether property ColorNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The ColorNode::configurations property specifies the list of
        /// supported node configurations.
        /// \exception DepthSense::InvalidOperationException the node no longer exists
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::ColorNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::ColorNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the ColorNode::configurations property
        ///
        /// Gets the value of the ColorNode::configurations property.
        ///
        ///
        /// \return the value of the ColorNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::ColorNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::ColorNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The brightness
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t brightness;
        #endif
        /// Gets the value of the ColorNode::brightness property
        ///
        /// Gets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::brightness property
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getBrightness ();
        /// Sets the value of the ColorNode::brightness property
        ///
        /// Sets the value of the ColorNode::brightness property.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getBrightness(), brightnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setBrightness (int32_t value);
        /// Checks whether property ColorNode::brightness is read-only
        ///
        /// Checks whether property ColorNode::brightness is read-only.
        ///
        /// The ColorNode::brightness property accepts a value ranging
        /// from -10 to 10 with a step of 1. This is a relative value
        /// where increasing values indicate increasing brightness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::brightness is read-only
        ///
        /// \sa setBrightness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool brightnessIsReadOnly ();
        /// The contrast
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t contrast;
        #endif
        /// Gets the value of the ColorNode::contrast property
        ///
        /// Gets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::contrast property
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getContrast ();
        /// Sets the value of the ColorNode::contrast property
        ///
        /// Sets the value of the ColorNode::contrast property.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getContrast(), contrastIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setContrast (int32_t value);
        /// Checks whether property ColorNode::contrast is read-only
        ///
        /// Checks whether property ColorNode::contrast is read-only.
        ///
        /// The ColorNode::contrast property accepts a value ranging
        /// from 1 to 32 with a step of 1. This is a relative value
        /// where increasing values indicate increasing contrast.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::contrast is read-only
        ///
        /// \sa setContrast()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool contrastIsReadOnly ();
        /// The saturation
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t saturation;
        #endif
        /// Gets the value of the ColorNode::saturation property
        ///
        /// Gets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::saturation property
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSaturation ();
        /// Sets the value of the ColorNode::saturation property
        ///
        /// Sets the value of the ColorNode::saturation property.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSaturation(), saturationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSaturation (int32_t value);
        /// Checks whether property ColorNode::saturation is read-only
        ///
        /// Checks whether property ColorNode::saturation is read-only.
        ///
        /// The ColorNode::saturation property accepts a value ranging
        /// from 0 to 20 with a step of 1. This is a relative value
        /// where increasing values indicate increasing saturation.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::saturation is read-only
        ///
        /// \sa setSaturation()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool saturationIsReadOnly ();
        /// The hue
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t hue;
        #endif
        /// Gets the value of the ColorNode::hue property
        ///
        /// Gets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::hue property
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getHue ();
        /// Sets the value of the ColorNode::hue property
        ///
        /// Sets the value of the ColorNode::hue property.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getHue(), hueIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setHue (int32_t value);
        /// Checks whether property ColorNode::hue is read-only
        ///
        /// Checks whether property ColorNode::hue is read-only.
        ///
        /// The ColorNode::hue property accepts a value ranging from
        /// -5 to 5 with a step of 1. The value is expressed in
        /// degrees multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::hue is read-only
        ///
        /// \sa setHue()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool hueIsReadOnly ();
        /// The gamma
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t gamma;
        #endif
        /// Gets the value of the ColorNode::gamma property
        ///
        /// Gets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::gamma property
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getGamma ();
        /// Sets the value of the ColorNode::gamma property
        ///
        /// Sets the value of the ColorNode::gamma property.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getGamma(), gammaIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setGamma (int32_t value);
        /// Checks whether property ColorNode::gamma is read-only
        ///
        /// Checks whether property ColorNode::gamma is read-only.
        ///
        /// The ColorNode::gamma property accepts a value ranging from
        /// 100 to 200 with a step of 1. The value is expressed in
        /// gamma multiplied by 100.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::gamma is read-only
        ///
        /// \sa setGamma()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool gammaIsReadOnly ();
        /// The white balance
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t whiteBalance;
        #endif
        /// Gets the value of the ColorNode::whiteBalance property
        ///
        /// Gets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalance property
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getWhiteBalance ();
        /// Sets the value of the ColorNode::whiteBalance property
        ///
        /// Sets the value of the ColorNode::whiteBalance property.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalance(), whiteBalanceIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalance (int32_t value);
        /// Checks whether property ColorNode::whiteBalance is read-only
        ///
        /// Checks whether property ColorNode::whiteBalance is read-only.
        ///
        /// The ColorNode::whiteBalance property accepts a value
        /// ranging from 2800 (incandescent) to 6500 (daylight) with a
        /// step of 1850. The value is expressed as a color
        /// temperature in Kelvin.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalance is read-only
        ///
        /// \sa setWhiteBalance()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceIsReadOnly ();
        /// The sharpness
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t sharpness;
        #endif
        /// Gets the value of the ColorNode::sharpness property
        ///
        /// Gets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::sharpness property
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getSharpness ();
        /// Sets the value of the ColorNode::sharpness property
        ///
        /// Sets the value of the ColorNode::sharpness property.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getSharpness(), sharpnessIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setSharpness (int32_t value);
        /// Checks whether property ColorNode::sharpness is read-only
        ///
        /// Checks whether property ColorNode::sharpness is read-only.
        ///
        /// The ColorNode::sharpness property accepts a value ranging
        /// from 0 to 10 with a step of 1.This is a relative value
        /// where increasing values indicate increasing sharpness.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::sharpness is read-only
        ///
        /// \sa setSharpness()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool sharpnessIsReadOnly ();
        /// The exposure
        ///
        /// The ColorNode::exposure property accepts a value ranging
        /// from 156 to 5000 with a step of 1 and is expressed in
        /// 100s units
        ///
        /// On Windows, the following mapping is applied:
        ///
        /// <table>
        /// <tr><td>156 - 233</td><td>1/64 seconds</td></tr>
        /// <tr><td>234 - 467</td><td>1/32 seconds</td></tr>
        /// <tr><td>468 - 936</td><td>1/16 seconds</td></tr>
        /// <tr><td>937 - 1874</td><td>1/8 seconds</td></tr>
        /// <tr><td>1875 - 3749</td><td>1/4 seconds</td></tr>
        /// <tr><td>3750 - 5000</td><td>1/2 seconds</td></tr>
        /// </table>
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t exposure;
        #endif
        /// Gets the value of the ColorNode::exposure property
        ///
        /// Gets the value of the ColorNode::exposure property.
        ///
        /// The ColorNode::exposure property accepts a value ranging
        /// from 156 to 5000 with a step of 1 and is expressed in
        /// 100s units
        ///
        /// On Windows, the following mapping is applied:
        ///
        /// <table>
        /// <tr><td>156 - 233</td><td>1/64 seconds</td></tr>
        /// <tr><td>234 - 467</td><td>1/32 seconds</td></tr>
        /// <tr><td>468 - 936</td><td>1/16 seconds</td></tr>
        /// <tr><td>937 - 1874</td><td>1/8 seconds</td></tr>
        /// <tr><td>1875 - 3749</td><td>1/4 seconds</td></tr>
        /// <tr><td>3750 - 5000</td><td>1/2 seconds</td></tr>
        /// </table>
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposure property
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getExposure ();
        /// Sets the value of the ColorNode::exposure property
        ///
        /// Sets the value of the ColorNode::exposure property.
        ///
        /// The ColorNode::exposure property accepts a value ranging
        /// from 156 to 5000 with a step of 1 and is expressed in
        /// 100s units
        ///
        /// On Windows, the following mapping is applied:
        ///
        /// <table>
        /// <tr><td>156 - 233</td><td>1/64 seconds</td></tr>
        /// <tr><td>234 - 467</td><td>1/32 seconds</td></tr>
        /// <tr><td>468 - 936</td><td>1/16 seconds</td></tr>
        /// <tr><td>937 - 1874</td><td>1/8 seconds</td></tr>
        /// <tr><td>1875 - 3749</td><td>1/4 seconds</td></tr>
        /// <tr><td>3750 - 5000</td><td>1/2 seconds</td></tr>
        /// </table>
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposure(), exposureIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposure (int32_t value);
        /// Checks whether property ColorNode::exposure is read-only
        ///
        /// Checks whether property ColorNode::exposure is read-only.
        ///
        /// The ColorNode::exposure property accepts a value ranging
        /// from 156 to 5000 with a step of 1 and is expressed in
        /// 100s units
        ///
        /// On Windows, the following mapping is applied:
        ///
        /// <table>
        /// <tr><td>156 - 233</td><td>1/64 seconds</td></tr>
        /// <tr><td>234 - 467</td><td>1/32 seconds</td></tr>
        /// <tr><td>468 - 936</td><td>1/16 seconds</td></tr>
        /// <tr><td>937 - 1874</td><td>1/8 seconds</td></tr>
        /// <tr><td>1875 - 3749</td><td>1/4 seconds</td></tr>
        /// <tr><td>3750 - 5000</td><td>1/2 seconds</td></tr>
        /// </table>
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposure is read-only
        ///
        /// \sa setExposure()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureIsReadOnly ();
        /// The auto exposure mode
        ///
        /// The ColorNode::exposureAuto property specifies the auto
        /// exposure mode (either manual or aperture priority).
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::ExposureAuto exposureAuto;
        #endif
        /// Gets the value of the ColorNode::exposureAuto property
        ///
        /// Gets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto
        /// exposure mode (either manual or aperture priority).
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAuto property
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ExposureAuto getExposureAuto ();
        /// Sets the value of the ColorNode::exposureAuto property
        ///
        /// Sets the value of the ColorNode::exposureAuto property.
        ///
        /// The ColorNode::exposureAuto property specifies the auto
        /// exposure mode (either manual or aperture priority).
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAuto(), exposureAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided value is outside of the range of allowed values
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAuto (DepthSense::ExposureAuto value);
        /// Checks whether property ColorNode::exposureAuto is read-only
        ///
        /// Checks whether property ColorNode::exposureAuto is read-only.
        ///
        /// The ColorNode::exposureAuto property specifies the auto
        /// exposure mode (either manual or aperture priority).
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAuto is read-only
        ///
        /// \sa setExposureAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoIsReadOnly ();
        /// Whether to enable the auto exposure priority mode
        ///
        /// The ColorNode::exposureAutoPriority property specifies
        /// whether to enable the auto exposure priority mode. If set
        /// to true, the frame rate can be dynamically modified by the
        /// device. Otherwise, the frame rate must remain constant.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool exposureAutoPriority;
        #endif
        /// Gets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Gets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property specifies
        /// whether to enable the auto exposure priority mode. If set
        /// to true, the frame rate can be dynamically modified by the
        /// device. Otherwise, the frame rate must remain constant.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::exposureAutoPriority property
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getExposureAutoPriority ();
        /// Sets the value of the ColorNode::exposureAutoPriority property
        ///
        /// Sets the value of the ColorNode::exposureAutoPriority property.
        ///
        /// The ColorNode::exposureAutoPriority property specifies
        /// whether to enable the auto exposure priority mode. If set
        /// to true, the frame rate can be dynamically modified by the
        /// device. Otherwise, the frame rate must remain constant.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getExposureAutoPriority(), exposureAutoPriorityIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setExposureAutoPriority (bool value);
        /// Checks whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// Checks whether property ColorNode::exposureAutoPriority is read-only.
        ///
        /// The ColorNode::exposureAutoPriority property specifies
        /// whether to enable the auto exposure priority mode. If set
        /// to true, the frame rate can be dynamically modified by the
        /// device. Otherwise, the frame rate must remain constant.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::exposureAutoPriority is read-only
        ///
        /// \sa setExposureAutoPriority()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool exposureAutoPriorityIsReadOnly ();
        /// Whether to enable automatic white balance.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool whiteBalanceAuto;
        #endif
        /// Gets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Gets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the ColorNode::whiteBalanceAuto property
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getWhiteBalanceAuto ();
        /// Sets the value of the ColorNode::whiteBalanceAuto property
        ///
        /// Sets the value of the ColorNode::whiteBalanceAuto property.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getWhiteBalanceAuto(), whiteBalanceAutoIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setWhiteBalanceAuto (bool value);
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// Checks whether property ColorNode::whiteBalanceAuto is read-only.
        ///
        /// The ColorNode::whiteBalanceAuto property specifies whether
        /// to enable automatic white balance.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property ColorNode::whiteBalanceAuto is read-only
        ///
        /// \sa setWhiteBalanceAuto()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool whiteBalanceAutoIsReadOnly ();
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::ColorNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::ColorNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
            ::DepthSense::Pointer< uint8_t > colorMap;
            /// The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
            ::DepthSense::Pointer< uint8_t > compressedData;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::ColorNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in s
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in s
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a color sample is captured
        ///
        /// The \c newSampleReceived event is raised when a color sample
        /// is captured.
        ///
        /// \param colorMap The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.
        /// \param compressedData The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in s
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in s
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::ColorNode, NewSampleReceivedData, void (*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::ColorNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::ColorNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.colorMap, data.compressedData, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::ColorNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, DepthSense::ColorNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::ColorNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p colorMap</td><td>The color map. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, the output format is BGR, otherwise the output format is YUY2.</td></tr>
            ///   <tr><td>\p compressedData</td><td>The compressed data. If \c captureConfiguration::compression is DepthSense::COMPRESSION_TYPE_MJPEG, this array contains the compmressed data.</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::ColorNode obj, ::DepthSense::Pointer< uint8_t > colorMap, ::DepthSense::Pointer< uint8_t > compressedData, DepthSense::ColorNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::ColorNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::ColorNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class DepthNode DepthSense.hxx
    /// Represents a depth stream data source
    ///
    /// The DepthNode class allows to capture depth data with the depth sensor
    /// of a given camera device.
    class DepthNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API DepthNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API DepthNode (const DepthNode& other);
        DEPTHSENSE_API DepthNode& operator= (const DepthNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~DepthNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit DepthNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::DepthNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::DepthNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::DepthNode type object
        ///
        /// Returns the DepthSense::DepthNode type object
        ///
        /// \return the DepthSense::DepthNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The mode of the camera
        ///
        /// A type enumerating the various operating modes supported
        /// by depth sensors.
        enum CameraMode
        {
            CAMERA_MODE_UNKNOWN = -1,
            CAMERA_MODE_CLOSE_MODE = 0,
            CAMERA_MODE_LONG_RANGE = 1,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String CameraMode_toString_p (CameraMode value);
        #endif
        /// Converts a DepthSense::DepthNode::CameraMode value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::CameraMode, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string CameraMode_toString (CameraMode value)
        {
            return CameraMode_toString_p(value).unmarshal();
        }
        enum OverheatingStatus
        {
            OVERHEATING_STATUS_TEMPERATURE_NORMAL = 0,
            OVERHEATING_STATUS_SOFT_OVERHEATING = 1,
            OVERHEATING_STATUS_HARD_OVERHEATING = 2,
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String OverheatingStatus_toString_p (OverheatingStatus value);
        #endif
        /// Converts a DepthSense::DepthNode::OverheatingStatus value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::DepthNode::OverheatingStatus, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string OverheatingStatus_toString (OverheatingStatus value)
        {
            return OverheatingStatus_toString_p(value).unmarshal();
        }
        /// \struct Configuration DepthSense.hxx
        /// The configuration of a depth node
        ///   
        /// The Configuration struct holds the configuration of a depth node.
        struct DEPTHSENSE_API Configuration
        {
            Configuration ();
            /// Constructs a Configuration instance
            ///
            /// Constructs a Configuration instance, initializing the instance fields with the provided values.
            ///
            /// \param frameFormat the value of the Configuration::frameFormat field
            /// \param framerate the value of the Configuration::framerate field
            /// \param mode the value of the Configuration::mode field
            /// \param saturation the value of the Configuration::saturation field
            Configuration (DepthSense::FrameFormat frameFormat, int32_t framerate, DepthSense::DepthNode::CameraMode mode, bool saturation);
            /// the frame format and resolution
            DepthSense::FrameFormat frameFormat;
            /// the frame rate in frames per second
            int32_t framerate;
            /// the mode
            DepthSense::DepthNode::CameraMode mode;
            /// whether the saturation is enabled or not
            bool saturation;
            /// Compares two Configuration instances for equality
            ///
            /// Checks whether the current Configuration instance is equal to the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Configuration& other) const;
            /// Compares two Configuration instances for inequality
            ///
            /// Checks whether the current Configuration instance is different from the Configuration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Configuration& other) const;
        };
        /// \struct Acceleration DepthSense.hxx
        /// The acceleration returned by the camera
        ///
        /// The Acceleration struct holds the 3 axis acceleration
        /// expressed in g (9.81 m/s) units. Coordinates are
        /// expressed in the same coordinates as the vertices.
        struct DEPTHSENSE_API Acceleration
        {
            Acceleration ();
            /// Constructs a Acceleration instance
            ///
            /// Constructs a Acceleration instance, initializing the instance fields with the provided values.
            ///
            /// \param x the value of the Acceleration::x field
            /// \param y the value of the Acceleration::y field
            /// \param z the value of the Acceleration::z field
            Acceleration (float x, float y, float z);
            /// the x acceleration
            float x;
            /// the y acceleration
            float y;
            /// the z acceleration
            float z;
            /// Compares two Acceleration instances for equality
            ///
            /// Checks whether the current Acceleration instance is equal to the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is equal to instance \p other
            bool operator== (const Acceleration& other) const;
            /// Compares two Acceleration instances for inequality
            ///
            /// Checks whether the current Acceleration instance is different from the Acceleration instance \p other.
            ///
            /// \param other the instance to compare the current instance with
            /// \return whether the current instance is different from instance \p other
            bool operator!= (const Acceleration& other) const;
        };
        /// Set the active configuration by name
        ///
        /// When setting a new active configuration, the active calibration will be reset to 0 and the
        /// active configuration will be flushed and replaced with the provided one. The newly active 
        /// configuration will be written immediately on the device.
        ///
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::ArgumentException the name doesn't match any known configuration
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node or the stream is already enabled
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        ///
        /// \param name the name of the configuration to be used
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfigurationByName (const char* name);
        /// Whether to enable confidence map computation
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableConfidenceMap;
        #endif
        /// Gets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Gets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableConfidenceMap property
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableConfidenceMap ();
        /// Sets the value of the DepthNode::enableConfidenceMap property
        ///
        /// Sets the value of the DepthNode::enableConfidenceMap property.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableConfidenceMap(), enableConfidenceMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableConfidenceMap (bool value);
        /// Checks whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// Checks whether property DepthNode::enableConfidenceMap is read-only.
        ///
        /// The DepthNode::enableConfidenceMap property specifies
        /// whether to enable confidence map computation and make it
        /// available through the \c confidenceMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableConfidenceMap is read-only
        ///
        /// \sa setEnableConfidenceMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableConfidenceMapIsReadOnly ();
        /// Whether to enable phase map computation
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enablePhaseMap;
        #endif
        /// Gets the value of the DepthNode::enablePhaseMap property
        ///
        /// Gets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enablePhaseMap property
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnablePhaseMap ();
        /// Sets the value of the DepthNode::enablePhaseMap property
        ///
        /// Sets the value of the DepthNode::enablePhaseMap property.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnablePhaseMap(), enablePhaseMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnablePhaseMap (bool value);
        /// Checks whether property DepthNode::enablePhaseMap is read-only
        ///
        /// Checks whether property DepthNode::enablePhaseMap is read-only.
        ///
        /// The DepthNode::enablePhaseMap property specifies whether
        /// to enable phase map computation and make it available
        /// through the \c phaseMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enablePhaseMap is read-only
        ///
        /// \sa setEnablePhaseMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enablePhaseMapIsReadOnly ();
        /// Whether to enable fixed point depth map computation
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMap;
        #endif
        /// Gets the value of the DepthNode::enableDepthMap property
        ///
        /// Gets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMap property
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMap ();
        /// Sets the value of the DepthNode::enableDepthMap property
        ///
        /// Sets the value of the DepthNode::enableDepthMap property.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMap(), enableDepthMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMap (bool value);
        /// Checks whether property DepthNode::enableDepthMap is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMap is read-only.
        ///
        /// The DepthNode::enableDepthMap property specifies whether
        /// to enable fixed point depth map computation and make it
        /// available through the \c depthMap argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMap is read-only
        ///
        /// \sa setEnableDepthMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapIsReadOnly ();
        /// Whether to enable floating point depth map computation
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDepthMapFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDepthMapFloatingPoint ();
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableDepthMapFloatingPoint property.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDepthMapFloatingPoint(), enableDepthMapFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDepthMapFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableDepthMapFloatingPoint is read-only.
        ///
        /// The DepthNode::enableDepthMapFloatingPoint property
        /// specifies whether to enable floating point depth map
        /// computation and make it available through the \c
        /// depthMapFloatingPoint argument of the \c newSampleReceived
        /// event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDepthMapFloatingPoint is read-only
        ///
        /// \sa setEnableDepthMapFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDepthMapFloatingPointIsReadOnly ();
        /// Whether to enable fixed point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVertices;
        #endif
        /// Gets the value of the DepthNode::enableVertices property
        ///
        /// Gets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVertices property
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVertices ();
        /// Sets the value of the DepthNode::enableVertices property
        ///
        /// Sets the value of the DepthNode::enableVertices property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVertices(), enableVerticesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVertices (bool value);
        /// Checks whether property DepthNode::enableVertices is read-only
        ///
        /// Checks whether property DepthNode::enableVertices is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable fixed point vertices computation and make it
        /// available through the \c vertices argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVertices is read-only
        ///
        /// \sa setEnableVertices()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesIsReadOnly ();
        /// Whether to enable floating point vertices computation
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableVerticesFloatingPoint;
        #endif
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Gets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableVerticesFloatingPoint ();
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property
        ///
        /// Sets the value of the DepthNode::enableVerticesFloatingPoint property.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableVerticesFloatingPoint(), enableVerticesFloatingPointIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableVerticesFloatingPoint (bool value);
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// Checks whether property DepthNode::enableVerticesFloatingPoint is read-only.
        ///
        /// The DepthNode::enableVertices property specifies whether
        /// to enable floating point vertices computation and make it
        /// available through the \c verticesFloatingPoint argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableVerticesFloatingPoint is read-only
        ///
        /// \sa setEnableVerticesFloatingPoint()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableVerticesFloatingPointIsReadOnly ();
        /// Whether the depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMap3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMap3Planes property
        ///
        /// Gets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMap3Planes property
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMap3Planes ();
        /// Sets the value of the DepthNode::depthMap3Planes property
        ///
        /// Sets the value of the DepthNode::depthMap3Planes property.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMap3Planes(), depthMap3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMap3Planes (bool value);
        /// Checks whether property DepthNode::depthMap3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMap3Planes is read-only.
        ///
        /// The DepthNode::depthMap3Planes property specifies whether
        /// the \c depthMap buffer is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMap3Planes is read-only
        ///
        /// \sa setDepthMap3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMap3PlanesIsReadOnly ();
        /// Whether the floating point depth map is the XYZ coordinates as a planar representation or only the Z coordinate
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool depthMapFloatingPoint3Planes;
        #endif
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Gets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getDepthMapFloatingPoint3Planes ();
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property
        ///
        /// Sets the value of the DepthNode::depthMapFloatingPoint3Planes property.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getDepthMapFloatingPoint3Planes(), depthMapFloatingPoint3PlanesIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setDepthMapFloatingPoint3Planes (bool value);
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// Checks whether property DepthNode::depthMapFloatingPoint3Planes is read-only.
        ///
        /// The DepthNode::depthMapFloatingPoint3Planes property specifies whether
        /// the \c depthMapFloatingPoint is the XYZ coordinates as a planar representation (true)
        /// or only the Z coordinate (false).
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::depthMapFloatingPoint3Planes is read-only
        ///
        /// \sa setDepthMapFloatingPoint3Planes()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool depthMapFloatingPoint3PlanesIsReadOnly ();
        /// Whether to enable UV map computation
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableUvMap;
        #endif
        /// Gets the value of the DepthNode::enableUvMap property
        ///
        /// Gets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableUvMap property
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableUvMap ();
        /// Sets the value of the DepthNode::enableUvMap property
        ///
        /// Sets the value of the DepthNode::enableUvMap property.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableUvMap(), enableUvMapIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableUvMap (bool value);
        /// Checks whether property DepthNode::enableUvMap is read-only
        ///
        /// Checks whether property DepthNode::enableUvMap is read-only.
        ///
        /// The DepthNode::enableUvMap property specifies whether to
        /// enable UV map computation and make it available through
        /// the \c uvMap argument of the \c newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableUvMap is read-only
        ///
        /// \sa setEnableUvMap()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableUvMapIsReadOnly ();
        /// Whether to enable the accelerometer data
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableAccelerometer;
        #endif
        /// Gets the value of the DepthNode::enableAccelerometer property
        ///
        /// Gets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableAccelerometer property
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableAccelerometer ();
        /// Sets the value of the DepthNode::enableAccelerometer property
        ///
        /// Sets the value of the DepthNode::enableAccelerometer property.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableAccelerometer(), enableAccelerometerIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableAccelerometer (bool value);
        /// Checks whether property DepthNode::enableAccelerometer is read-only
        ///
        /// Checks whether property DepthNode::enableAccelerometer is read-only.
        ///
        /// The DepthNode::enableAccelerometer property specifies
        /// whether to capture the accelerometer data and make it
        /// available through the \c acceleration argument of the \c
        /// newSampleReceived event.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableAccelerometer is read-only
        ///
        /// \sa setEnableAccelerometer()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableAccelerometerIsReadOnly ();
        #ifdef DEPTHSENSE_DOC
        @property bool _noFan;
        #endif
        /// Gets the value of the DepthNode::_noFan property
        ///
        /// Gets the value of the DepthNode::_noFan property.
        ///
        /// \return the value of the DepthNode::_noFan property
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool get_noFan ();
        /// Sets the value of the DepthNode::_noFan property
        ///
        /// Sets the value of the DepthNode::_noFan property.
        ///
        /// \param value the value to set
        ///
        /// \sa get_noFan(), _noFanIsReadOnly()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void set_noFan (bool value);
        /// Checks whether property DepthNode::_noFan is read-only
        ///
        /// Checks whether property DepthNode::_noFan is read-only.
        ///
        /// \return whether property DepthNode::_noFan is read-only
        ///
        /// \sa set_noFan()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool _noFanIsReadOnly ();
        /// Specify the confidence threshold
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t confidenceThreshold;
        #endif
        /// Gets the value of the DepthNode::confidenceThreshold property
        ///
        /// Gets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::confidenceThreshold property
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getConfidenceThreshold ();
        /// Sets the value of the DepthNode::confidenceThreshold property
        ///
        /// Sets the value of the DepthNode::confidenceThreshold property.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfidenceThreshold(), confidenceThresholdIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfidenceThreshold (int32_t value);
        /// Checks whether property DepthNode::confidenceThreshold is read-only
        ///
        /// Checks whether property DepthNode::confidenceThreshold is read-only.
        ///
        /// The DepthNode::confidenceThreshold property specifies the
        /// confidence threshold.
        ///
        /// The DepthNode::confidenceThreshold property is deprecated 
        /// and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::confidenceThreshold is read-only
        ///
        /// \sa setConfidenceThreshold()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool confidenceThresholdIsReadOnly ();
        /// Specify the illumination level
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera. This property
        /// is currently not available for DS325 cameras.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property int32_t illuminationLevel;
        #endif
        /// Gets the value of the DepthNode::illuminationLevel property
        ///
        /// Gets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera. This property
        /// is currently not available for DS325 cameras.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::illuminationLevel property
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getIlluminationLevel ();
        /// Sets the value of the DepthNode::illuminationLevel property
        ///
        /// Sets the value of the DepthNode::illuminationLevel property.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera. This property
        /// is currently not available for DS325 cameras.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getIlluminationLevel(), illuminationLevelIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the value passed is out of range
        /// \exception DepthSense::NotSupportedException the property is not supported by the node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setIlluminationLevel (int32_t value);
        /// Checks whether property DepthNode::illuminationLevel is read-only
        ///
        /// Checks whether property DepthNode::illuminationLevel is read-only.
        ///
        /// The DepthNode::illuminationLevel property specifies the
        /// illumination level to be used by the camera. This property
        /// is currently not available for DS325 cameras.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::illuminationLevel is read-only
        ///
        /// \sa setIlluminationLevel()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool illuminationLevelIsReadOnly ();
        /// Whether to enable denoising
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property bool enableDenoising;
        #endif
        /// Gets the value of the DepthNode::enableDenoising property
        ///
        /// Gets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::enableDenoising property
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getEnableDenoising ();
        /// Sets the value of the DepthNode::enableDenoising property
        ///
        /// Sets the value of the DepthNode::enableDenoising property.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getEnableDenoising(), enableDenoisingIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setEnableDenoising (bool value);
        /// Checks whether property DepthNode::enableDenoising is read-only
        ///
        /// Checks whether property DepthNode::enableDenoising is read-only.
        ///
        /// The DepthNode::enableDenoising property specifies whether
        /// to enable denoising.
        ///
        /// Note: The denoising filter will be applied only on the phase map and not on the other maps.
        ///
        /// The DepthNode::enableDenoising property is deprecated and will be removed in future builds.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::enableDenoising is read-only
        ///
        /// \sa setEnableDenoising()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool enableDenoisingIsReadOnly ();
        /// The node configuration
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property DepthSense::DepthNode::Configuration configuration;
        #endif
        /// Gets the value of the DepthNode::configuration property
        ///
        /// Gets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return the value of the DepthNode::configuration property
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::Configuration getConfiguration ();
        /// Sets the value of the DepthNode::configuration property
        ///
        /// Sets the value of the DepthNode::configuration property.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \param value the value to set
        ///
        /// \sa getConfiguration(), configurationIsReadOnly()
        ///
        /// \exception DepthSense::UnauthorizedAccessException the parent context does not have control of the current node
        /// \exception DepthSense::ArgumentException the provided configuration is invalid
        /// \exception DepthSense::ConfigurationException the provided configuration is valid but failed to apply
        /// \exception DepthSense::StreamingException streaming was enabled at the time of the call and could not be restarted because of a device or software error
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void setConfiguration (DepthSense::DepthNode::Configuration value);
        /// Checks whether property DepthNode::configuration is read-only
        ///
        /// Checks whether property DepthNode::configuration is read-only.
        ///
        /// The DepthNode::configuration property specifies the
        /// configuration of the depth node.
        ///
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible or the operation cannot be performed on this node
        ///
        /// \return whether property DepthNode::configuration is read-only
        ///
        /// \sa setConfiguration()
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool configurationIsReadOnly ();
        /// The list of supported node configurations
        ///   
        /// The DepthNode::configurations property specifies the list
        /// of supported node configurations.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::DepthNode::Configuration > configurations;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::DepthNode::Configuration > _p_getConfigurations ();
        public:
        /// Gets the value of the DepthNode::configurations property
        ///
        /// Gets the value of the DepthNode::configurations property.
        ///
        ///
        /// \return the value of the DepthNode::configurations property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::DepthNode::Configuration > getConfigurations ()
        {
            std::vector< DepthSense::DepthNode::Configuration > retval = _p_getConfigurations().unmarshal();
            return retval;
        }
        /// The depth sensor range
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        #ifdef DEPTHSENSE_DOC
        @property(readonly) float range;
        #endif
        /// Gets the value of the DepthNode::range property
        ///
        /// Gets the value of the DepthNode::range property.
        ///
        /// The DepthNode::range property specifies the range of the
        /// depth sensor, expressed in meters.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::IOException the operation failed because of an IO error
        ///
        /// \return the value of the DepthNode::range property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API float getRange ();
        /// Return the list of name of known configurations
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< std::string > configurationList;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< ::DSI::String > _p_getConfigurationList ();
        public:
        /// Gets the value of the DepthNode::configurationList property
        ///
        /// Gets the value of the DepthNode::configurationList property.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        /// \exception DepthSense::NotSupportedException this operation is not supported by this camera
        ///
        /// \return the value of the DepthNode::configurationList property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< std::string > getConfigurationList ()
        {
            ::DSI::Vector< ::DSI::String > _tmp9 = _p_getConfigurationList();
            std::vector< std::string > retval;
            int32_t _tmp10 = (int32_t) _tmp9.size();
            for (int _i = 0; _i < _tmp10; _i++)
            {
                retval.push_back(_tmp9[_i].unmarshal());
            }
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        /// \struct NewSampleReceivedData DepthSense.hxx
        /// Holds the DepthSense::DepthNode::NewSampleReceivedEvent arguments
        ///
        /// The NewSampleReceivedData struct holds the DepthSense::DepthNode::NewSampleReceivedEvent parameters and is passed to callbacks connected to that event.
        struct NewSampleReceivedData
        {
            /// the confidence map
            ::DepthSense::Pointer< int16_t > confidenceMap;
            /// The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
            ::DepthSense::Pointer< int16_t > phaseMap;
            /// The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
            ::DepthSense::Pointer< int16_t > depthMap;
            /// The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            ::DepthSense::Pointer< float > depthMapFloatingPoint;
            /// The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.
            ::DepthSense::Pointer< DepthSense::Vertex > vertices;
            /// The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
            ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint;
            /// The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
            ::DepthSense::Pointer< DepthSense::UV > uvMap;
            /// The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.
            DepthSense::DepthNode::Acceleration acceleration;
            /// the system model parameters that were in effect at the time of capture
            DepthSense::StereoCameraParameters stereoCameraParameters;
            /// the camera configuration that was in effect at the time of capture
            DepthSense::DepthNode::Configuration captureConfiguration;
            /// the time of capture of the sample, expressed in s
            uint64_t timeOfCapture;
            /// the time of arrival of the sample in the library, expressed in s
            uint64_t timeOfArrival;
            /// the number of dropped samples since the last \c newSampleReceived event was raised
            int32_t droppedSampleCount;
            /// the number of dropped samples since the streaming was started
            int32_t cumulativeDroppedSampleCount;
        };
        /// \class NewSampleReceivedEvent DepthSense.hxx
        /// Event raised when a depth sample is captured
        ///
        /// The \c newSampleReceived event is raised when a depth sample
        /// is captured.
        ///
        /// \param confidenceMap the confidence map
        /// \param phaseMap The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.
        /// \param depthMap The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.
        /// \param depthMapFloatingPoint The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
        /// \param vertices The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.
        /// \param verticesFloatingPoint The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.
        /// \param uvMap The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.
        /// \param acceleration The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.
        /// \param stereoCameraParameters the system model parameters that were in effect at the time of capture
        /// \param captureConfiguration the camera configuration that was in effect at the time of capture
        /// \param timeOfCapture the time of capture of the sample, expressed in s
        /// \param timeOfArrival the time of arrival of the sample in the library, expressed in s
        /// \param droppedSampleCount the number of dropped samples since the last \c newSampleReceived event was raised
        /// \param cumulativeDroppedSampleCount the number of dropped samples since the streaming was started
        class NewSampleReceivedEvent : public DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>
        {
            private:
            NewSampleReceivedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(func)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::DepthNode, NewSampleReceivedData, void (*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    _func(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::DepthNode obj, NewSampleReceivedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::DepthNode, NewSampleReceivedData, ObjectType, void (ObjectType::*) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount)>::_method))(obj, data.confidenceMap, data.phaseMap, data.depthMap, data.depthMapFloatingPoint, data.vertices, data.verticesFloatingPoint, data.uvMap, data.acceleration, data.stereoCameraParameters, data.captureConfiguration, data.timeOfCapture, data.timeOfArrival, data.droppedSampleCount, data.cumulativeDroppedSampleCount);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::DepthNode, NewSampleReceivedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, DepthSense::DepthNode::NewSampleReceivedData data))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new DepthSense::MethodHandler<DepthSense::DepthNode, NewSampleReceivedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p confidenceMap</td><td>the confidence map</td></tr>
            ///   <tr><td>\p phaseMap</td><td>The phase map. This map represents the radial phase ([0 - 2[) with respect to the center of the depth camera. Valid values lie in the range [0 - 32767]. Saturated pixels are given the special value \c -32767.</td></tr>
            ///   <tr><td>\p depthMap</td><td>The depth map in fixed point format. This map represents the cartesian depth of each pixel, expressed in millimeters. Valid values lies in the range [0 - 31999]. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p depthMapFloatingPoint</td><td>The depth map in floating point format. This map represents the cartesian depth of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p vertices</td><td>The vertices in fixed point format. This map represents the cartesian 3D coordinates of each pixel, expressed in millimeters. Saturated pixels are given the special value \c 32002.</td></tr>
            ///   <tr><td>\p verticesFloatingPoint</td><td>The vertices in floating point format. This map represents the cartesian 3D coordinates of each pixel, expressed in meters. Saturated pixels are given the special value \c -2.0.</td></tr>
            ///   <tr><td>\p uvMap</td><td>The UV mapping. This map represents the normalized coordinates of each pixel in the color map. Invalid pixels are given the special value \c -FLT_MAX.</td></tr>
            ///   <tr><td>\p acceleration</td><td>The acceleration of the camera when the frame was captured. The sampling frequency of this value is 1 Hz.</td></tr>
            ///   <tr><td>\p stereoCameraParameters</td><td>the system model parameters that were in effect at the time of capture</td></tr>
            ///   <tr><td>\p captureConfiguration</td><td>the camera configuration that was in effect at the time of capture</td></tr>
            ///   <tr><td>\p timeOfCapture</td><td>the time of capture of the sample, expressed in s</td></tr>
            ///   <tr><td>\p timeOfArrival</td><td>the time of arrival of the sample in the library, expressed in s</td></tr>
            ///   <tr><td>\p droppedSampleCount</td><td>the number of dropped samples since the last \c newSampleReceived event was raised</td></tr>
            ///   <tr><td>\p cumulativeDroppedSampleCount</td><td>the number of dropped samples since the streaming was started</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::DepthNode obj, ::DepthSense::Pointer< int16_t > confidenceMap, ::DepthSense::Pointer< int16_t > phaseMap, ::DepthSense::Pointer< int16_t > depthMap, ::DepthSense::Pointer< float > depthMapFloatingPoint, ::DepthSense::Pointer< DepthSense::Vertex > vertices, ::DepthSense::Pointer< DepthSense::FPVertex > verticesFloatingPoint, ::DepthSense::Pointer< DepthSense::UV > uvMap, DepthSense::DepthNode::Acceleration acceleration, DepthSense::StereoCameraParameters stereoCameraParameters, DepthSense::DepthNode::Configuration captureConfiguration, uint64_t timeOfCapture, uint64_t timeOfArrival, int32_t droppedSampleCount, int32_t cumulativeDroppedSampleCount))
            {
                DepthSense::Event<DepthSense::DepthNode, NewSampleReceivedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c newSampleReceived event object
        ///
        /// Returns a reference to the \c newSampleReceived event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c newSampleReceived event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::DepthNode::NewSampleReceivedEvent& newSampleReceivedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class UnsupportedNode DepthSense.hxx
    /// Represents an unsupported stream data source
    ///   
    /// The UnsupportedNode class allows to have some information about 
    /// an unsupported device. This node can not be registered neither controlled.
    class UnsupportedNode
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Node
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API UnsupportedNode (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::Context;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API UnsupportedNode (const UnsupportedNode& other);
        DEPTHSENSE_API UnsupportedNode& operator= (const UnsupportedNode& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~UnsupportedNode ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Node& iface);
        DEPTHSENSE_API explicit UnsupportedNode (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::UnsupportedNode& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::UnsupportedNode& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// Returns the DepthSense::UnsupportedNode type object
        ///
        /// \return the DepthSense::UnsupportedNode type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The reason the node is unsupported
        ///   
        /// The UnsupportedNode::reason property specifies the reason
        /// why the node is not supported.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string reason;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getReason ();
        public:
        /// Gets the value of the UnsupportedNode::reason property
        ///
        /// Gets the value of the UnsupportedNode::reason property.
        ///
        ///
        /// \return the value of the UnsupportedNode::reason property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getReason ()
        {
            std::string retval = _p_getReason().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        /// The node serial number
        ///   
        /// The Node::serialNumber property specifies the serial
        /// number of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Node::serialNumber property
        ///
        /// Gets the value of the Node::serialNumber property.
        ///
        ///
        /// \return the value of the Node::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node vendor ID
        ///   
        /// The Node::VID property specifies the vendor ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t VID;
        #endif
        /// Gets the value of the Node::VID property
        ///
        /// Gets the value of the Node::VID property.
        ///
        ///
        /// \return the value of the Node::VID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getVID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node product ID
        ///   
        /// The Node::PID property specifies the product ID of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t PID;
        #endif
        /// Gets the value of the Node::PID property
        ///
        /// Gets the value of the Node::PID property.
        ///
        ///
        /// \return the value of the Node::PID property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getPID ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node revision
        ///   
        /// The Node::revision property specifies the revision of the
        /// node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t revision;
        #endif
        /// Gets the value of the Node::revision property
        ///
        /// Gets the value of the Node::revision property.
        ///
        ///
        /// \return the value of the Node::revision property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getRevision ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// The node media interface
        ///   
        /// The Node::mediaInterface property specifies the media
        /// interface of the node.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t mediaInterface;
        #endif
        /// Gets the value of the Node::mediaInterface property
        ///
        /// Gets the value of the Node::mediaInterface property.
        ///
        ///
        /// \return the value of the Node::mediaInterface property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getMediaInterface ();
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Device DepthSense.hxx
    /// Represents a camera device
    ///   
    /// The Device class represents a physical camera device connected
    /// to the host. It exposes device information (serial number,
    /// model and so on) and contains a number of stream data sources
    /// designated as \em nodes.
    class Device
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Device (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Context;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Device (const Device& other);
        DEPTHSENSE_API Device& operator= (const Device& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Device ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Device (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Device& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Device& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Device type object
        ///
        /// Returns the DepthSense::Device type object
        ///
        /// \return the DepthSense::Device type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// The camera model
        ///
        /// An enumeration comprising all the camera models supported by
        /// DepthSense SDK.
        enum Model
        {
            MODEL_UNKNOWN = 0,/*!< unknown model */
            MODEL_DS320 = 1,/*!< DepthSense 320 */
            MODEL_DS325 = 2,/*!< DepthSense 325 */
            MODEL_DS311 = 3,/*!< DepthSense 311 */
            MODEL_GENERIC = 4,/*!< Generic */
            MODEL_VF0780 = 5,/*!< DepthSense 325 */
            MODEL_TICDK = 7,/*!< TI-CDK */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Model_toString_p (Model value);
        #endif
        /// Converts a DepthSense::Device::Model value to a string
        ///
        /// Converts the provided enumeration value to a string.
        ///
        /// \param value the enumeration value to convert
        ///
        /// \return the name of the enumeration member whose value is \p value, or, if \p value is not a member of DepthSense::Device::Model, its numeric representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Model_toString (Model value)
        {
            return Model_toString_p(value).unmarshal();
        }
        /// A bitmask of capabilities supported by the camera
        ///   
        /// A bitmask of capabilities supported by the camera.
        enum Capabilities
        {
            CAPABILITIES_COLOR = 1,/*!< the camera supports color streaming */
            CAPABILITIES_DEPTH = 2,/*!< the camera supports depth streaming */
            CAPABILITIES_AUDIO = 4,/*!< the camera supports audio streaming */
            CAPABILITIES_ACCELEROMETER = 8,/*!< the camera has an accelerometer */
        };
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API static DSI::String Capabilities_toString_p (Capabilities value);
        #endif
        /// Converts a DepthSense::Device::Capabilities value to a string
        ///
        /// Converts the provided bitmask to a string.
        ///
        /// \param value the bitmask to convert
        ///
        /// \return a string of the form <tt>"Flag1 | Flag2 | Flag3"</tt>; unknown bits are omitted from the representation
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        static inline std::string Capabilities_toString (Capabilities value)
        {
            return Capabilities_toString_p(value).unmarshal();
        }
        /// The camera serial number
        ///   
        /// The Device::serialNumber property specifies the serial
        /// number of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::string serialNumber;
        #endif
        private:
        DEPTHSENSE_API ::DSI::String _p_getSerialNumber ();
        public:
        /// Gets the value of the Device::serialNumber property
        ///
        /// Gets the value of the Device::serialNumber property.
        ///
        ///
        /// \return the value of the Device::serialNumber property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::string getSerialNumber ()
        {
            std::string retval = _p_getSerialNumber().unmarshal();
            return retval;
        }
        /// The camera model
        ///   
        /// The Device::model property specifies the model of the
        /// current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Model model;
        #endif
        /// Gets the value of the Device::model property
        ///
        /// Gets the value of the Device::model property.
        ///
        ///
        /// \return the value of the Device::model property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Model getModel ();
        /// The TOF controller firmware version
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t tofControllerVersion;
        #endif
        /// Gets the value of the Device::tofControllerVersion property
        ///
        /// Gets the value of the Device::tofControllerVersion property.
        ///
        /// The Device::tofControllerVersion property specifies the
        /// TOF controller firmware version of the current device.
        /// This property is initialized after the node has streamed
        /// for the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::tofControllerVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getTofControllerVersion ();
        /// The USB backend firmware version
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) int32_t usbBackendVersion;
        #endif
        /// Gets the value of the Device::usbBackendVersion property
        ///
        /// Gets the value of the Device::usbBackendVersion property.
        ///
        /// The Device::usbBackendVersion property specifies the USB
        /// backend firmware version of the current device. This
        /// property is initialized after the node has streamed for
        /// the first time.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::usbBackendVersion property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API int32_t getUsbBackendVersion ();
        /// The camera overheating status
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheating;
        #endif
        /// Gets the value of the Device::overheating property
        ///
        /// Gets the value of the Device::overheating property.
        ///
        /// The DepthNode::overheating property is true if at least one soft threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheating property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheating ();
        /// The camera overheated status
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        #ifdef DEPTHSENSE_DOC
        @property(readonly) bool overheated;
        #endif
        /// Gets the value of the Device::overheated property
        ///
        /// Gets the value of the Device::overheated property.
        ///
        /// The DepthNode::overheated property is true if at least one hard threshold has been exceeded
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this node
        ///
        /// \return the value of the Device::overheated property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API bool getOverheated ();
        /// The camera capabilities
        ///   
        /// The Device::capabilities property specifies the
        /// capabilities of the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::Device::Capabilities capabilities;
        #endif
        /// Gets the value of the Device::capabilities property
        ///
        /// Gets the value of the Device::capabilities property.
        ///
        ///
        /// \return the value of the Device::capabilities property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::Capabilities getCapabilities ();
        /// The stream data sources
        ///   
        /// The Device::nodes property specifies the stream data
        /// sources exposed by the current device.
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > nodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getNodes ();
        public:
        /// Gets the value of the Device::nodes property
        ///
        /// Gets the value of the Device::nodes property.
        ///
        ///
        /// \return the value of the Device::nodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getNodes().unmarshal();
            return retval;
        }
        /// The system model parameters
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        #ifdef DEPTHSENSE_DOC
        @property(readonly) DepthSense::StereoCameraParameters stereoCameraParameters;
        #endif
        /// Gets the value of the Device::stereoCameraParameters property
        ///
        /// Gets the value of the Device::stereoCameraParameters property.
        ///
        /// The DepthSense::StereoCameraParameters property specifies the system 
        /// model parameters.
        ///
        /// \exception DepthSense::InvalidOperationException the operation cannot be performed on this device
        ///
        /// \return the value of the Device::stereoCameraParameters property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::StereoCameraParameters getStereoCameraParameters ();
        /// \struct NodeAddedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeAddedEvent arguments
        ///
        /// The NodeAddedData struct holds the DepthSense::Device::NodeAddedEvent parameters and is passed to callbacks connected to that event.
        struct NodeAddedData
        {
            /// the node that was attached to the current device
            DepthSense::Node node;
        };
        /// \class NodeAddedEvent DepthSense.hxx
        /// Event raised when a node is attached to the current device
        ///   
        /// The \c nodeAdded event is raised when a stream data source
        /// is attached to the current device.
        ///
        /// \param node the node that was attached to the current device
        ///
        /// \sa NodeRemovedEvent
        class NodeAddedEvent : public DepthSense::Event<DepthSense::Device, NodeAddedData>
        {
            private:
            NodeAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeAddedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeAddedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeAddedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was attached to the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeAdded event object
        ///
        /// Returns a reference to the \c nodeAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeAddedEvent& nodeAddedEvent () const;
        /// \struct NodeRemovedData DepthSense.hxx
        /// Holds the DepthSense::Device::NodeRemovedEvent arguments
        ///
        /// The NodeRemovedData struct holds the DepthSense::Device::NodeRemovedEvent parameters and is passed to callbacks connected to that event.
        struct NodeRemovedData
        {
            /// the node that was detached from the current device
            DepthSense::Node node;
        };
        /// \class NodeRemovedEvent DepthSense.hxx
        /// Event raised when a node is detached from the current device
        ///   
        /// The \c nodeRemoved event is raised when a stream data source
        /// is detached from the current device.
        ///
        /// \param node the node that was detached from the current device
        ///
        /// \sa NodeAddedEvent
        class NodeRemovedEvent : public DepthSense::Event<DepthSense::Device, NodeRemovedData>
        {
            private:
            NodeRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Device, NodeRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node)>(func)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Device, NodeRemovedData, void (*) (DepthSense::Device obj, DepthSense::Node node, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    _func(obj, data.node, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Device obj, NodeRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Device, NodeRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Device obj, DepthSense::Node node)>::_method))(obj, data.node);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Device, NodeRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Device, NodeRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Device obj, DepthSense::Node node, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Device::NodeRemovedData data))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Device, NodeRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p node</td><td>the node that was detached from the current device</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Device obj, DepthSense::Node node))
            {
                DepthSense::Event<DepthSense::Device, NodeRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c nodeRemoved event object
        ///
        /// Returns a reference to the \c nodeRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c nodeRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Device::NodeRemovedEvent& nodeRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
    /// \class Context DepthSense.hxx
    /// Represents an application session
    ///   
    /// The Context class represents an application session (either a
    /// standalone session or a TCP/IP client connection). A context
    /// can group a number of nodes from different devices for simultaneous
    /// monitoring of several stream data sources.
    ///
    /// Object instances obtained from a given Context instance (such
    /// as the list of devices connected to the host, or the list of
    /// nodes belonging to a specific device) are implicitly attached
    /// to that Context instance, which is then termed the object's
    /// <em>parent context</em>. Any operation performed on a device
    /// or node automatically makes use of its parent context.
    class Context
    #ifdef DEPTHSENSE_DOC
        : public DepthSense::Interface
    #endif
    {
        private:
        void* _instance;
        DEPTHSENSE_API Context (void* instance);
        DEPTHSENSE_API void incref ();
        DEPTHSENSE_API void decref ();
        friend class ::DSI::Marshalling;
        friend class ::DSI::CMarshalling;
        friend class DepthSense::Interface;
        friend class DepthSense::AudioNode;
        friend class DepthSense::ColorNode;
        friend class DepthSense::DepthNode;
        friend class DepthSense::UnsupportedNode;
        friend class DepthSense::Device;
        friend class DepthSense::Node;
        public:
        DEPTHSENSE_API Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API Context (const Context& other);
        DEPTHSENSE_API Context& operator= (const Context& other);
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Returns the parent context
        ///
        /// Returns the context associated with the current interface.
        ///
        /// \return the parent context
        DEPTHSENSE_API DepthSense::Context getContext () const;
        #endif
        DEPTHSENSE_API ~Context ();
        #ifndef DEPTHSENSE_DOC
        DEPTHSENSE_API explicit Context (const DepthSense::Interface& iface);
        DEPTHSENSE_API bool operator== (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator!= (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator< (const DepthSense::Context& other) const;
        DEPTHSENSE_API bool operator> (const DepthSense::Context& other) const;
        #endif
        #ifndef DEPTHSENSE_DOC
        /// Checks if the current instance is set
        ///
        /// Checks if the current instance is set.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.isSet()</tt> expression is semantically equivalent to <tt>p != NULL</tt>.
        /// \par Example:
        /// <pre>
        /// DepthSense::AudioNode audioNode;
        /// bool b = audioNode.isSet(); // b is false
        /// </pre>
        ///
        /// \return whether the current instance is set
        DEPTHSENSE_API bool isSet () const;
        /// Unsets the current instance
        ///
        /// Unsets the current instance.
        ///
        /// Given a variable \c i (of type Interface) and a variable \c p (of type \c void*), the <tt>i.unset();</tt> statement is semantically equivalent to <tt>p = NULL;</tt>.
        DEPTHSENSE_API void unset ();
        /// Returns the runtime type of the current instance
        ///
        /// Returns the runtime type of the current instance.
        ///
        /// \return the runtime type of the current instance
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Type getType () const;
        #endif
        /// Returns the DepthSense::Context type object
        ///
        /// Returns the DepthSense::Context type object
        ///
        /// \return the DepthSense::Context type object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Type type ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \c localhost, port \c 6809.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(const char*), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create ();
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c 6809.
        ///
        /// \param hostname the host or IP address to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*, int32_t), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname);
        /// Connects to a DepthSense server
        ///   
        /// Connects to host \p hostname, port \c port.
        ///
        /// \param hostname the host or IP address to connect to
        /// \param port the port to connect to
        ///
        /// \return the resulting context
        ///
        /// \warning the \p hostname parameter is currently ignored,
        /// \c localhost is always used
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), createStandalone()
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context create (const char* hostname, int32_t port);
        /// Creates a standalone DepthSense context
        ///
        /// Creates a standalone DepthSense context.
        ///
        /// \return the resulting context
        ///
        /// \pre no standalone context must be active in the client application
        ///
        /// \sa create(), create(const char*), create(const char*, int32_t)
        ///
        /// \exception DepthSense::InvalidOperationException a standalone context is active
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API static DepthSense::Context createStandalone ();
        /// Runs the DepthSense event loop
        ///
        /// Runs the DepthSense event loop. The connected event
        /// handlers are run in the thread that called run().
        ///
        /// If the server throws an exception asynchronously (that is,
        /// not in reaction to a method call or property
        /// assignment/retrieval), it will be propagated to this
        /// method.
        ///
        /// To exit the event loop, call quit().
        ///
        /// \sa quit()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is already running in the current application
        /// \exception DepthSense::InitializationException an initialization error has occurred
        /// \exception DepthSense::StreamingException a streaming error has occurred
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::IOException a device I/O operation has failed
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void run ();
        /// Terminates the DepthSense event loop
        ///
        /// Terminates the DepthSense event loop.
        ///
        /// \sa run()
        ///
        /// \exception DepthSense::InvalidOperationException the DepthSense event loop is not running in the current application
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void quit ();
        /// Starts monitoring a node
        ///   
        /// Registers a node with the current context. All registered
        /// nodes will be used as actual stream data sources.
        /// If the streaming is already started, the registered node
        /// will automatically start streaming.
        ///
        /// \param node the node to be registered
        ///
        /// \sa unregisterNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, already registered or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::ConfigurationException a valid configuration failed to apply
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void registerNode (DepthSense::Node node);
        /// Stops monitoring a node
        ///    
        /// Removes the specified node from the list of monitored nodes of the
        /// current context.
        ///
        /// \param node the node to be unregistered
        ///
        /// \pre
        /// The provided node must have been subject to a prior call
        /// to registerNode().
        ///
        /// \sa registerNode(), getRegisteredNodes()
        ///
        /// \exception DepthSense::ArgumentException \p node is unset or not registered
        /// \exception DepthSense::StreamingException a streaming error has occured
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void unregisterNode (DepthSense::Node node);
        /// Starts the capture on the registered nodes
        ///    
        /// Starts the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa stopNodes()
        ///
        /// \exception DepthSense::ConfigurationException a valid node configuration failed to apply
        /// \exception DepthSense::StreamingException streaming could not be started
        /// \exception DepthSense::InvalidOperationException when video synchronization is enabled, the configurations of the depth and color nodes are incompatible
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void startNodes ();
        /// Stops the capture on the registered nodes
        ///    
        /// Stops the capture (streaming) on the nodes registered with the
        /// current context.
        ///
        /// \sa startNodes()
        ///
        /// \exception DepthSense::StreamingException streaming could not be stopped
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void stopNodes ();
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the device is detached from the host system.
        ///
        /// \param device the device to request control of
        ///
        /// \sa requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device);
        /// Requests control of a device
        ///   
        /// Requests full control access on \p device and its nodes. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a device or any of its exposed properties.
        /// This method will try to request the control of all the nodes of the DepthSense::Device.
        /// In case of failure, none of the nodes will be controlled. When a context has the control
        /// over a DepthSense::Device, the context will be granted control on any new node added to 
        /// the DepthSense::Device.
        ///
        /// \param device the device to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context already controls it
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Device device, int32_t timeout);
        /// Releases control of a device
        ///
        /// Releases full control access on \p device. If other clients/contexts
        /// are waiting for full control access on the same device or one of
        /// its nodes, control will be transferred to one of them, chosen
        /// randomly.
        ///
        /// \param device the device to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p device is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Device device);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// This methods blocks indefinitely until control is granted
        /// to the caller or the node is detached from the host system.
        ///
        /// \param node the node to request control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node, int32_t), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node);
        /// Requests control of a node
        ///   
        /// Requests full control access on \p node. This
        /// method provides a cooperation mechanism which allows multiple
        /// clients to share control over a specific camera device node. Only
        /// one client (i.e. one context) at a time can modify the
        /// configuration of a node or any of its exposed
        /// properties.
        ///
        /// \param node the node to request control of
        /// \param timeout the timeout in milliseconds
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), releaseControl(Device), releaseControl(Node)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, the current context already controls it, or the node is an DepthSense::UnsupportedNode node
        /// \exception DepthSense::TimeoutException \p timeout has expired before control could be obtained
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void requestControl (DepthSense::Node node, int32_t timeout);
        /// Releases control of a node
        ///
        /// Releases full control access on \p node. If other
        /// clients/contexts are waiting for full control access on
        /// the same node control will be transferred to one of them,
        /// chosen randomly.
        ///
        /// \param node the node to release control of
        ///
        /// \sa requestControl(Device), requestControl(Device, int32_t), requestControl(Node), requestControl(Node, int32_t), releaseControl(Device)
        ///
        /// \exception DepthSense::ArgumentException \p node is unset, has been disconnected from the host, or the current context does not control it
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API void releaseControl (DepthSense::Node node);
        /// Client-side version information
        ///
        /// The Context::getClientVersion method returns the client-side version information.
        ///
        /// \return the client-side version information
        ///
        /// \sa Context::getServerVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getClientVersion ();
        /// Server-side version information
        ///
        /// The Context::getServerVersion method returns the server-side version information.
        ///
        /// \return the server-side version information
        ///
        /// \sa Context::getClientVersion
        /// \sa getLibraryVersion
        ///
        /// \exception DepthSense::InvalidOperationException \p The current context is unset, or not connected to the DepthSense server, or is a standalone context  
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Version getServerVersion ();
        /// The list of registered nodes
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Node > registeredNodes;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Node > _p_getRegisteredNodes ();
        public:
        /// Gets the value of the Context::registeredNodes property
        ///
        /// Gets the value of the Context::registeredNodes property.
        ///
        /// The Context::registeredNodes property contains the list of
        /// nodes registered with registerNode().
        ///
        /// \sa registerNode(), unregisterNode()
        ///
        /// \return the value of the Context::registeredNodes property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Node > getRegisteredNodes ()
        {
            std::vector< DepthSense::Node > retval = _p_getRegisteredNodes().unmarshal();
            return retval;
        }
        /// The list of connected devices
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        #ifdef DEPTHSENSE_DOC
        @property(readonly) std::vector< DepthSense::Device > devices;
        #endif
        private:
        DEPTHSENSE_API ::DSI::Vector< DepthSense::Device > _p_getDevices ();
        public:
        /// Gets the value of the Context::devices property
        ///
        /// Gets the value of the Context::devices property.
        ///
        /// The Context::devices property contains the list of camera devices
        /// attached to the host.
        ///
        /// \return the value of the Context::devices property
        ///
        ///
        ///
        /// \exception DepthSense::TransportException a network or protocol error has occurred
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        std::vector< DepthSense::Device > getDevices ()
        {
            std::vector< DepthSense::Device > retval = _p_getDevices().unmarshal();
            return retval;
        }
        #ifndef DEPTHSENSE_DOC
        struct ClientConnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientConnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientConnectedEvent arguments
        ///
        /// The ClientConnectedData struct holds the DepthSense::Context::ClientConnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientConnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientConnectedEvent DepthSense.hxx
        /// Event raised when a client connects
        ///   
        /// The \c clientConnected event is raised when a client connects
        /// to the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientDisconnectedEvent
        class ClientConnectedEvent : public DepthSense::Event<DepthSense::Context, ClientConnectedData_p>
        {
            private:
            ClientConnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientConnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientConnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientConnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientConnectedData_p data)
                {
                    ClientConnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientConnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientConnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientConnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientConnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientConnected event object
        ///
        /// Returns a reference to the \c clientConnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientConnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientConnectedEvent& clientConnectedEvent () const;
        #ifndef DEPTHSENSE_DOC
        struct ClientDisconnectedData_p
        {
            ::DSI::String appName;
            int32_t pid;
            ::DSI::String sourceIP;
            int32_t sourcePort;
        };
        #endif
        /// \struct ClientDisconnectedData DepthSense.hxx
        /// Holds the DepthSense::Context::ClientDisconnectedEvent arguments
        ///
        /// The ClientDisconnectedData struct holds the DepthSense::Context::ClientDisconnectedEvent parameters and is passed to callbacks connected to that event.
        struct ClientDisconnectedData
        {
            /// the name of the client executable, or an empty string if it could not be determined
            std::string appName;
            /// the process ID of the client, or \c -1 if it could not be determined
            int32_t pid;
            /// the source IP address
            std::string sourceIP;
            /// the source IP port
            int32_t sourcePort;
        };
        /// \class ClientDisconnectedEvent DepthSense.hxx
        /// Event raised when a client disconnects
        ///   
        /// The \c clientDisconnected event is raised when a client
        /// disconnects from the DepthSense server.
        ///
        /// \param appName the name of the client executable, or an empty string if it could not be determined
        /// \param pid the process ID of the client, or \c -1 if it could not be determined
        /// \param sourceIP the source IP address
        /// \param sourcePort the source IP port
        ///
        /// \sa ClientConnectedEvent
        class ClientDisconnectedEvent : public DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>
        {
            private:
            ClientDisconnectedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class StructFunctionHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructFunctionHandler (Function func)
                    : _func(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _func(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructFunctionHandler* f = dynamic_cast<StructFunctionHandler*>(other);
                    return f != NULL && f->_func == _func;
                }
                private:
                Function _func;
            };
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            template <class ClosureDataType>
            class StructClosureHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (*Function) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, ClosureDataType closureData);
                StructClosureHandler (Function closure, ClosureDataType closureData)
                    : _closure(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    _closure(obj, publicData, _closureData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructClosureHandler* f = dynamic_cast<StructClosureHandler*>(other);
                    return f != NULL && f->_closure == _closure && f->_closureData == _closureData;
                }
                private:
                Function _closure;
                ClosureDataType _closureData;
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, ClientDisconnectedData_p, void (*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    _func(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class StructMethodHandler : public DepthSense::EventHandler<DepthSense::Context, ClientDisconnectedData_p>
            {
                public:
                typedef void (ObjectType::*Method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data);
                StructMethodHandler (ObjectType* obj, Method method)
                    : _obj(obj), _method(method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData_p data)
                {
                    ClientDisconnectedData publicData;
                    publicData.appName = data.appName.unmarshal();
                    publicData.pid = data.pid;
                    publicData.sourceIP = data.sourceIP.unmarshal();
                    publicData.sourcePort = data.sourcePort;
                    (_obj->*_method)(obj, publicData);
                }
                protected:
                virtual bool equals (EventHandlerBase* other) const
                {
                    StructMethodHandler* f = dynamic_cast<StructMethodHandler*>(other);
                    return f != NULL && f->_obj == _obj && f->_method == _method;
                }
                private:
                ObjectType* _obj;
                Method _method;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, ClientDisconnectedData_p data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, ClientDisconnectedData_p, ObjectType, void (ObjectType::*) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort)>::_method))(obj, data.appName.unmarshal(), data.pid, data.sourceIP.unmarshal(), data.sourcePort);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructFunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructFunctionHandler(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructClosureHandler<T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new StructMethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::ClientDisconnectedData data))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new StructMethodHandler<T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p appName</td><td>the name of the client executable, or an empty string if it could not be determined</td></tr>
            ///   <tr><td>\p pid</td><td>the process ID of the client, or \c -1 if it could not be determined</td></tr>
            ///   <tr><td>\p sourceIP</td><td>the source IP address</td></tr>
            ///   <tr><td>\p sourcePort</td><td>the source IP port</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, std::string appName, int32_t pid, std::string sourceIP, int32_t sourcePort))
            {
                DepthSense::Event<DepthSense::Context, ClientDisconnectedData_p>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c clientDisconnected event object
        ///
        /// Returns a reference to the \c clientDisconnected event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c clientDisconnected event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::ClientDisconnectedEvent& clientDisconnectedEvent () const;
        /// \struct DeviceAddedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceAddedEvent arguments
        ///
        /// The DeviceAddedData struct holds the DepthSense::Context::DeviceAddedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceAddedData
        {
            /// the camera device that was attached to the host
            DepthSense::Device device;
        };
        /// \class DeviceAddedEvent DepthSense.hxx
        /// Event raised when a camera device is attached to the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// attached to the host.
        ///
        /// \param device the camera device that was attached to the host
        ///
        /// \sa DeviceRemovedEvent
        class DeviceAddedEvent : public DepthSense::Event<DepthSense::Context, DeviceAddedData>
        {
            private:
            DeviceAddedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceAddedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceAddedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceAddedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceAddedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceAddedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceAddedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceAddedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceAddedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was attached to the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceAddedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceAdded event object
        ///
        /// Returns a reference to the \c deviceAdded event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceAdded event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceAddedEvent& deviceAddedEvent () const;
        /// \struct DeviceRemovedData DepthSense.hxx
        /// Holds the DepthSense::Context::DeviceRemovedEvent arguments
        ///
        /// The DeviceRemovedData struct holds the DepthSense::Context::DeviceRemovedEvent parameters and is passed to callbacks connected to that event.
        struct DeviceRemovedData
        {
            /// the camera device that was detached from the host
            DepthSense::Device device;
        };
        /// \class DeviceRemovedEvent DepthSense.hxx
        /// Event raised when a camera device is detached from the host
        ///   
        /// The \c deviceAdded event is raised when a camera device is
        /// detached from the host.
        ///
        /// \param device the camera device that was detached from the host
        ///
        /// \sa DeviceAddedEvent
        class DeviceRemovedEvent : public DepthSense::Event<DepthSense::Context, DeviceRemovedData>
        {
            private:
            DeviceRemovedEvent (DSI::InstanceBase* instance, int eventID, int setEnableRequestID)
                : DepthSense::Event<DepthSense::Context, DeviceRemovedData>(instance, eventID, setEnableRequestID)
            {
            }
            friend class DSI::InstanceBase;
            #ifndef DEPTHSENSE_DOC
            class FunctionHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                FunctionHandler (DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>::Function func)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device)>(func)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device);
                }
            };
            template <class ClosureDataType>
            class ClosureHandler : public DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>
            {
                public:
                ClosureHandler (typename DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>::Function closure, ClosureDataType closureData)
                    : DepthSense::GenericFunctionHandler<DepthSense::Context, DeviceRemovedData, void (*) (DepthSense::Context obj, DepthSense::Device device, ClosureDataType closureData)>(closure), _closureData(closureData)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    _func(obj, data.device, _closureData);
                }
                private:
                ClosureDataType _closureData;
            };
            template <class ObjectType>
            class MethodHandler : public DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>
            {
                public:
                MethodHandler (ObjectType* obj, typename DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::Method method)
                    : DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>(obj, method)
                {
                }
                virtual void operator () (DepthSense::Context obj, DeviceRemovedData data)
                {
                    ((DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_obj)->*(DepthSense::GenericMethodHandler<DepthSense::Context, DeviceRemovedData, ObjectType, void (ObjectType::*) (DepthSense::Context obj, DepthSense::Device device)>::_method))(obj, data.device);
                }
            };
            #endif
            public:
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::FunctionHandler<DepthSense::Context, DeviceRemovedData>(handlerFunc));
            }
            /// Connects a function to the current event
            ///
            /// Connects a function to the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void connect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new FunctionHandler(handlerFunc));
            }
            /// Disconnects a function from the current event
            ///
            /// Disconnects a function from the current event. The parameters of the supplied function must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \param handlerFunc the handler function
            ///
            /// \exception DepthSense::ArgumentException \p handlerFunc is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            void disconnect (void (*handlerFunc) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new FunctionHandler(handlerFunc));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::ClosureHandler<DepthSense::Context, DeviceRemovedData, T>(closure, closureData));
            }
            /// Connects a closure to the current event
            ///
            /// Connects a closure to the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new ClosureHandler<T>(closure, closureData));
            }
            /// Disconnects a closure from the current event
            ///
            /// Disconnects a closure from the current event. The parameters of the supplied closure must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            ///   <tr><td>\p closureData</td><td>the user-supplied lexical environment</td></tr>
            /// </table>
            ///
            /// \tparam T the type of the user-supplied lexical environment
            ///
            /// \param closure the closure
            /// \param closureData the user-supplied lexical environment
            ///
            /// \exception DepthSense::ArgumentException the closure identified by \p closure and \p closureData is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (void (*closure) (DepthSense::Context obj, DepthSense::Device device, T closureData), T closureData)
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new ClosureHandler<T>(closure, closureData));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p data</td><td>the event parameters</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Context::DeviceRemovedData data))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new DepthSense::MethodHandler<DepthSense::Context, DeviceRemovedData, T>(obj, method));
            }
            /// Connects a method to the current event
            ///
            /// Connects a method to the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is already connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void connect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::connect(new MethodHandler<T>(obj, method));
            }
            /// Disconnects a method from the current event
            ///
            /// Disconnects a method from the current event. The parameters of the supplied method must be:
            ///
            /// <table>
            ///   <tr><td>\p obj</td><td>the object for which the event was raised</td></tr>
            ///   <tr><td>\p device</td><td>the camera device that was detached from the host</td></tr>
            /// </table>
            ///
            /// \tparam T the method's parent type
            ///
            /// \param obj the object on which to invoke \p method
            /// \param method the method
            ///
            /// \exception DepthSense::ArgumentException the method handler identified by \p obj and \p method is not connected to the current event
            /// \exception std::bad_alloc not enough memory to perform the requested operation
            template <class T>
            void disconnect (T* obj, void (T::*method) (DepthSense::Context obj, DepthSense::Device device))
            {
                DepthSense::Event<DepthSense::Context, DeviceRemovedData>::disconnect(new MethodHandler<T>(obj, method));
            }
        };
        /// Returns the \c deviceRemoved event object
        ///
        /// Returns a reference to the \c deviceRemoved event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c deviceRemoved event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Context::DeviceRemovedEvent& deviceRemovedEvent () const;
        #ifndef DEPTHSENSE_DOC
        /// Returns the \c propertyChanged event object
        ///
        /// Returns a reference to the \c propertyChanged event object,  which can be used to connect handlers to that event.
        ///
        /// \return the \c propertyChanged event object
        ///
        /// \exception std::bad_alloc not enough memory to perform the requested operation
        DEPTHSENSE_API DepthSense::Interface::PropertyChangedEvent& propertyChangedEvent () const;
        #endif
    };
};
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Interface >
    {
        size_t operator() (DepthSense::Interface iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::AudioNode >
    {
        size_t operator() (DepthSense::AudioNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::ColorNode >
    {
        size_t operator() (DepthSense::ColorNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::DepthNode >
    {
        size_t operator() (DepthSense::DepthNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::UnsupportedNode >
    {
        size_t operator() (DepthSense::UnsupportedNode iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Context >
    {
        size_t operator() (DepthSense::Context iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Device >
    {
        size_t operator() (DepthSense::Device iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Node >
    {
        size_t operator() (DepthSense::Node iface) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::AudioNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::AudioNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::AudioNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< float > >
    {
        size_t operator() (DepthSense::Property< float > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< bool > >
    {
        size_t operator() (DepthSense::Property< bool > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ColorNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ColorNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::ColorNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< int32_t > >
    {
        size_t operator() (DepthSense::Property< int32_t > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::ExposureAuto > >
    {
        size_t operator() (DepthSense::Property< DepthSense::ExposureAuto > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::DepthNode::Configuration > >
    {
        size_t operator() (DepthSense::Property< DepthSense::DepthNode::Configuration > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::DepthNode::Configuration > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< std::string > > >
    {
        size_t operator() (DepthSense::Property< std::vector< std::string > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::string > >
    {
        size_t operator() (DepthSense::Property< std::string > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Node > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Node > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< std::vector< DepthSense::Device > > >
    {
        size_t operator() (DepthSense::Property< std::vector< DepthSense::Device > > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Model > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Model > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::Device::Capabilities > >
    {
        size_t operator() (DepthSense::Property< DepthSense::Device::Capabilities > property) const;
    };
}
#endif
#ifdef __DS_HAVE_STD_HASH
namespace std
{
    template <>
    struct DEPTHSENSE_API hash< DepthSense::Property< DepthSense::StereoCameraParameters > >
    {
        size_t operator() (DepthSense::Property< DepthSense::StereoCameraParameters > property) const;
    };
}
#endif
#endif // _DEPTHSENSE_PUBLIC_HXX
